
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\client\\audio\\container.d.ts",
      "/**\n * An AudioSourceNode container which handles the strategy of node type to use for playback.\n * Used by the Sound interface which controls playback.\n * This class is for internal use only and should not be used by external callers.\n */\ndeclare class AudioContainer {\n  constructor(src: string);\n\n  /**\n   * The audio source path\n   */\n  src: string;\n\n  /**\n   * The Audio Node used to control this sound\n   * @defaultValue `undefined`\n   */\n  sourceNode: AudioBufferSourceNode | MediaElementAudioSourceNode | undefined;\n\n  /**\n   * The GainNode used to control volume\n   * @defaultValue `undefined`\n   */\n  gainNode: GainNode | undefined;\n\n  /**\n   * Is this container using an AudioBuffer?\n   * @defaultValue `false`\n   */\n  isBuffer: boolean;\n\n  /**\n   * Whether we have attempted to load the audio node or not, and whether it failed.\n   * @see {@link LOAD_STATES}\n   * @defaultValue `AudioContainer.LOAD_STATES.NONE`\n   */\n  loadState: AudioContainer.LOAD_STATES;\n\n  /**\n   * Is the audio source currently playing?\n   * @defaultValue `false`\n   */\n  playing: boolean;\n\n  /**\n   * Should the audio source loop?\n   * @defaultValue `false`\n   * @internal\n   */\n  protected _loop: boolean;\n\n  get loop(): boolean;\n  set loop(looping: boolean);\n\n  /**\n   * The maximum duration, in seconds, for which an AudioBuffer will be used.\n   * Otherwise a streaming media element will be used.\n   * @defaultValue `10 * 60`\n   */\n  static MAX_BUFFER_DURATION: number;\n\n  /**\n   * The sequence of container loading states.\n   */\n  static LOAD_STATES: {\n    FAILED: -1;\n    NONE: 0;\n    LOADING: 1;\n    LOADED: 2;\n  };\n\n  /**\n   * Has the audio file been loaded either fully or for streaming.\n   */\n  get loaded(): boolean;\n\n  /**\n   * Did the audio file fail to load.\n   */\n  get failed(): boolean;\n\n  /**\n   * A reference to the AudioBuffer if the sourceNode is a AudioBufferSourceNode.\n   */\n  get buffer(): AudioBuffer | null | undefined;\n\n  /**\n   * The game audio context used throughout the application.\n   */\n  get context(): AudioContext;\n\n  /**\n   * The total duration of the audio source in seconds\n   */\n  get duration(): number | undefined;\n\n  /**\n   * A reference to the HTMLMediaElement, if the sourceNode is a MediaElementAudioSourceNode.\n   */\n  get element(): HTMLMediaElement | undefined;\n\n  /**\n   * Load the source node required for playback of this audio source\n   */\n  load(): Promise<void>;\n\n  /**\n   * Create the initial audio node used for playback.\n   * Determine the node type to use based on cached state and sound duration.\n   * @internal\n   */\n  protected _createNode(): Promise<AudioBufferSourceNode | MediaElementAudioSourceNode | undefined>;\n\n  /**\n   * Create an Audio source node using a buffered array.\n   * @internal\n   */\n  protected _createAudioBuffer(): Promise<AudioBuffer>;\n\n  /**\n   * Create a AudioBufferSourceNode using a provided AudioBuffer\n   * @internal\n   */\n  protected _createAudioBufferSourceNode(buffer: AudioBuffer): AudioBufferSourceNode;\n\n  /**\n   * Create an HTML5 Audio element which has loaded the metadata for the provided source.\n   * @internal\n   */\n  protected _createAudioElement(): Promise<HTMLAudioElement>;\n\n  /**\n   * Create a MediaElementAudioSourceNode using a provided HTMLAudioElement\n   * @internal\n   */\n  protected _createMediaElementAudioSourceNode(element: HTMLAudioElement): MediaElementAudioSourceNode;\n\n  /**\n   * Begin playback for the source node.\n   * @param offset  - The desired start time\n   * @param onended - A callback function for when playback concludes naturally\n   */\n  play(offset: number, onended: () => void): void;\n\n  /**\n   * Pre-playback actions that are needed depending on the node type\n   * @internal\n   */\n  protected _configureNode(): void;\n\n  /**\n   * Terminate playback for the source node.\n   */\n  stop(): void;\n\n  /**\n   * Perform cleanup actions when the sound has finished playing. For\n   * MediaElementAudioSourceNodes, this also means optionally restarting if\n   * the sound is supposed to loop.\n   * @param onended - A callback provided by the owner of the container that gets fired when the sound ends.\n   * @internal\n   */\n  protected _onEnd(onended: () => void): void;\n\n  /**\n   * Unload the MediaElementAudioSourceNode to terminate any ongoing\n   * connections.\n   * @internal\n   */\n  protected _unloadMediaNode(): void;\n}\n\ndeclare namespace AudioContainer {\n  type LOAD_STATES = ValueOf<typeof AudioContainer['LOAD_STATES']>;\n}\n"
    ]
  