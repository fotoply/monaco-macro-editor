
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\client\\pixi\\layers\\walls.d.ts",
      "import { ConfiguredDocumentClass, ConfiguredObjectClassForName } from '../../../../types/helperTypes';\nimport { PasteOptions } from '../placeables';\n\ndeclare global {\n  /**\n   * The Walls canvas layer which provides a container for Wall objects within the rendered Scene.\n   * @see {@link WallDocument}\n   * @see {@link Wall}\n   */\n  class WallsLayer extends PlaceablesLayer<'Wall', WallsLayer.LayerOptions> {\n    constructor();\n\n    /**\n     * An array of Wall objects which represent the boundaries of the canvas.\n     * @defaultValue `new Set()`\n     */\n    boundaries: Set<Wall>;\n\n    /**\n     * A graphics layer used to display chained Wall selection\n     * @defaultValue `null`\n     */\n    chain: PIXI.Graphics | null;\n\n    /**\n     * Track whether we are currently within a chained placement workflow\n     * @defaultValue `false`\n     */\n    protected _chain: boolean;\n\n    /**\n     * Track whether the layer is currently toggled to snap at exact grid precision\n     * @defaultValue `false`\n     */\n    protected _forceSnap: boolean;\n\n    /**\n     * Track the most recently created or updated wall data for use with the clone tool\n     * @defaultValue `null`\n     * @remarks This is intentional `public` because it is accessed from Wall\n     */\n    _cloneType: ReturnType<foundry.documents.BaseWall['toJSON']> | null;\n\n    /**\n     * Reference the last interacted wall endpoint for the purposes of chaining\n     * @defaultValue\n     * ```\n     * {\n     *   point: null,\n     * }\n     * ```\n     */\n    protected last: {\n      point: PointArray | null;\n    };\n\n    /**\n     * @remarks This is not overridden in foundry but reflects the real behavior.\n     */\n    static get instance(): Canvas['walls'];\n\n    /**\n     * @defaultValue\n     * ```\n     * mergeObject(super.layerOptions, {\n     *  name: \"walls\"\n     *  controllableObjects: true,\n     *  sortActiveTop: true,\n     *  zIndex: 40\n     * })\n     * ```\n     */\n    static override get layerOptions(): WallsLayer.LayerOptions;\n\n    static override documentName: 'Wall';\n\n    /**\n     * An Array of Wall instances in the current Scene which act as Doors.\n     */\n    get doors(): InstanceType<ConfiguredObjectClassForName<'Wall'>>[];\n\n    /**\n     * Gate the precision of wall snapping to become less precise for small scale maps.\n     * @remarks Returns `1 | 4 | 8 | 16`\n     */\n    get gridPrecision(): number;\n\n    override draw(): Promise<this>;\n\n    override deactivate(): this;\n\n    /**\n     * Perform initialization steps for the WallsLayer whenever the composition of walls in the Scene is changed.\n     * Cache unique wall endpoints and identify interior walls using overhead roof tiles.\n     */\n    initialize(): void;\n\n    /**\n     * Initialization to identify all intersections between walls.\n     * These intersections are cached and used later when computing point source polygons.\n     */\n    identifyWallIntersections(): void;\n\n    /**\n     * Identify walls which are treated as \"interior\" because they are contained fully within a roof tile.\n     */\n    identifyInteriorWalls(): void;\n\n    /**\n     * Given a point and the coordinates of a wall, determine which endpoint is closer to the point\n     * @param point - The origin point of the new Wall placement\n     * @param wall  - The existing Wall object being chained to\n     * @returns The [x,y] coordinates of the starting endpoint\n     */\n    static getClosestEndpoint(point: Point, wall: InstanceType<ConfiguredObjectClassForName<'Wall'>>): PointArray;\n\n    /**\n     * Test whether movement along a given Ray collides with a Wall.\n     * @param ray     - The attempted movement\n     * @param options - Options which customize how collision is tested\n     * @returns False if there are no Walls\n     *          True if the Ray is outside the Canvas\n     *          Whether any collision occurred if mode is \"any\"\n     *          An array of collisions, if mode is \"all\"\n     *          The closest collision, if mode is \"closest\"\n     */\n    checkCollision(ray: Ray, options: CollisionOptions & { mode: 'all' }): boolean | PolygonVertex[];\n    checkCollision(ray: Ray, options: CollisionOptions & { mode: 'closest' }): boolean | PolygonVertex;\n    checkCollision(ray: Ray, options: CollisionOptions & { mode: 'any' }): boolean;\n    checkCollision(ray: Ray, options: Omit<CollisionOptions, 'mode'>): boolean;\n    checkCollision(ray: Ray, options: CollisionOptions): boolean | PolygonVertex;\n    checkCollision(ray: Ray, options?: CollisionOptions): boolean;\n\n    /**\n     * Highlight the endpoints of Wall segments which are currently group-controlled on the Walls layer\n     */\n    highlightControlledSegments(): void;\n\n    override releaseAll(options?: PlaceableObject.ReleaseOptions): number;\n\n    override pasteObjects(\n      position: Point,\n      options?: PasteOptions\n    ): Promise<InstanceType<ConfiguredDocumentClass<typeof foundry.documents.BaseWall>>[]>;\n\n    /**\n     * Create temporary WallDocument instances which represent the rectangular boundaries of the canvas.\n     * @internal\n     */\n    protected _createBoundaries(): void;\n\n    /**\n     * Pan the canvas view when the cursor position gets close to the edge of the frame\n     * @param event - The originating mouse movement event\n     * @param x     - The x-coordinate\n     * @param y     - The y-coordinate\n     */\n    protected _panCanvasEdge(event: MouseEvent, x: number, y: number): void | ReturnType<Canvas['animatePan']>;\n\n    /**\n     * Get the endpoint coordinates for a wall placement, snapping to grid at a specified precision\n     * Require snap-to-grid until a redesign of the wall chaining system can occur.\n     * @param  point - The initial candidate point\n     * @param  snap  - Whether to snap to grid\n     *                 (default: `true`)\n     * @returns The endpoint coordinates [x,y]\n     */\n    protected _getWallEndpointCoordinates(point: Point, { snap }?: { snap?: boolean }): PointArray;\n\n    /**\n     * The Scene Controls tools provide several different types of prototypical Walls to choose from\n     * This method helps to translate each tool into a default wall data configuration for that type\n     * @param tool - The active canvas tool\n     */\n    protected _getWallDataFromActiveTool(tool: string):\n      | {\n          light: foundry.CONST.WALL_SENSE_TYPES;\n          sight: foundry.CONST.WALL_SENSE_TYPES;\n          sound: foundry.CONST.WALL_SENSE_TYPES;\n          move: foundry.CONST.WALL_SENSE_TYPES;\n          door?: foundry.CONST.WALL_DOOR_TYPES;\n        }\n      | this['_cloneType'];\n\n    protected override _onDragLeftStart(event: PIXI.InteractionEvent): void;\n\n    protected override _onDragLeftMove(event: PIXI.InteractionEvent): void;\n\n    protected override _onDragLeftDrop(event: PIXI.InteractionEvent): void;\n\n    protected override _onDragLeftCancel(event: PointerEvent): void;\n\n    protected override _onClickRight(event: PIXI.InteractionEvent): void;\n\n    /** @deprecated since v9 */\n    computePolygon(\n      origin: Point,\n      radius: number,\n      options?: ComputePolygonOptions\n    ): { rays: Ray[]; los: PIXI.Polygon; fov: PIXI.Polygon };\n\n    /** @deprecated since v9 */\n    getRayCollisions(ray: Ray, options: RayCollisionsOptions & { mode: 'all' }): RayIntersection[];\n    getRayCollisions(ray: Ray, options: RayCollisionsOptions & { mode: 'closest' }): RayIntersection | null;\n    getRayCollisions(ray: Ray, options: RayCollisionsOptions & { mode: 'any' }): boolean;\n    getRayCollisions(ray: Ray, options?: Partial<Omit<RayCollisionsOptions, 'mode'>>): RayIntersection[];\n    getRayCollisions(ray: Ray, options?: RayCollisionsOptions): RayIntersection[] | RayIntersection | boolean | null;\n\n    /**\n     * An array of all the unique perception-blocking endpoints which are present in the layer\n     * We keep this array cached for faster sight polygon computations\n     * @deprecated since v9\n     */\n    get endpoints(): PointArray[];\n\n    /**\n     * Given an array of Wall instances, identify the unique endpoints across all walls.\n     * @param walls   - An array of Wall instances\n     * @param options - Additional options which modify the set of endpoints identified\n     *                  (defaultValue: `{}`)\n     * @returns An array of endpoints\n     * @deprecated since v9\n     */\n    static getUniqueEndpoints(\n      walls:\n        | InstanceType<ConfiguredObjectClassForName<'Wall'>>[]\n        | Set<InstanceType<ConfiguredObjectClassForName<'Wall'>>>,\n      options?: EndpointOptions\n    ): PointArray[];\n  }\n\n  namespace WallsLayer {\n    interface LayerOptions extends PlaceablesLayer.LayerOptions<'Wall'> {\n      name: 'walls';\n      controllableObjects: true;\n      objectClass: typeof Wall;\n      quadtree: true;\n      sheetClass: ConstructorOf<FormApplication>;\n      sortActiveTop: boolean;\n      zIndex: number;\n    }\n  }\n}\n\ninterface EndpointOptions {\n  /**\n   * An optional bounding rectangle within which the endpoint must lie.\n   */\n  bounds?: NormalizedRectangle;\n\n  /**\n   * The type of polygon being computed: \"movement\", \"sight\", or \"sound\"\n   * @defaultValue `'movement'`\n   */\n  type?: 'movement' | 'sight' | 'sound';\n}\n\ninterface CollisionOptions {\n  /**\n   * Which collision type to check: movement, sight, sound\n   * @defaultValue `'move'`\n   */\n  type?: 'move' | 'sight' | 'sound';\n\n  /**\n   * Which type of collisions are returned: any, closest, all\n   * @defaultValue `'any'`\n   */\n  mode?: 'any' | 'closest' | 'all';\n}\n\ninterface ComputePolygonOptions {\n  /**\n   * The type of polygon being computed: \"movement\", \"sight\", or \"sound\"\n   * @defaultValue `'sight'`\n   */\n  type?: 'movement' | 'sight' | 'sound';\n\n  /**\n   * An optional limited angle of emission with which to restrict polygons\n   * @defaultValue `360`\n   */\n  angle?: number;\n\n  /**\n   * The desired radial density of emission for rays, in degrees\n   * @defaultValue `6`\n   */\n  density?: number;\n\n  /**\n   * The current angle of rotation, used when the angle is limited\n   * @defaultValue `0`\n   */\n  rotation?: number;\n\n  /**\n   * Compute sight that is fully unrestricted by walls\n   * @defaultValue `false`\n   */\n  unrestricted?: boolean;\n}\n\ninterface RayCollisionsOptions {\n  /**\n   * Which collision type to check: movement, sight, sound\n   * @defaultValue `'movement'`\n   */\n  type?: 'movement' | 'sight' | 'sound';\n\n  /**\n   * Which type of collisions are returned: any, closest, all\n   * @defaultValue `'all'`\n   */\n  mode?: `any` | `closest` | `all`;\n\n  /**\n   * Internal performance tracking\n   */\n  _performance?: { tests: number };\n}\n"
    ]
  