
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\types\\config.d.ts",
      "declare global {\n  /**\n   * Some global variables (such as {@link game}) are only initialized after certain events have happened during the\n   * initialization of Foundry VTT. For that reason, the correct types for these variables include the types for the\n   * uninitialized state.\n   *\n   * While this is correct from a type checking perspective, it can be inconvenient to have to type guard these global\n   * variables everywhere. Some users might prefer the convenience over the 100% correctness in type checking.\n   *\n   * For this reason, this interface provides a way for users to configure certain global variables to be typed more\n   * leniently, i.e., as the types of their initialized state. This is done via declaration merging. To configure a\n   * specific global variable to be typed leniently, the user simply needs to merge a property with the name of the\n   * variable into this interface (the type doesn't matter).\n   *\n   * The currently supported variables are:\n   * - {@link game}\n   * - {@link socket}\n   * - {@link ui}\n   * - {@link canvas}\n   *\n   * @example\n   * ```typescript\n   * declare global {\n   *   interface LenientGlobalVariableTypes {\n   *     game: never; // the type doesn't matter\n   *   }\n   * }\n   *\n   * const referenceToGame: Game = game; // ok! :)\n   * ```\n   */\n  // eslint-disable-next-line @typescript-eslint/no-empty-interface\n  interface LenientGlobalVariableTypes {}\n\n  /**\n   * This interface is used to configure the used document classes at a type\n   * level. Module and system authors should use declaration merging to provide\n   * the types of their configured document classes. It is extremely important\n   * that this is kept in sync with the configuration that actually happens at\n   * runtime.\n   *\n   * @example\n   * ```typescript\n   * // myActor.ts\n   * class MyActor extends Actor {}\n   *\n   * // entryPoint.ts\n   * import { MyActor } from './myActor'\n   *\n   * hooks.once('init', () => {\n   *   CONFIG.Actor.documentClass = typeof MyActor;\n   * });\n   *\n   * declare global {\n   *   interface DocumentClassConfig {\n   *     Actor: typeof MyActor\n   *   }\n   * }\n   * ```\n   */\n  //eslint-disable-next-line @typescript-eslint/no-empty-interface\n  interface DocumentClassConfig {}\n\n  /**\n   * This interface is used to configure the used object classes at a type\n   * level. Module and system authors should use declaration merging to provide\n   * the types of their configured object classes. It is extremely important\n   * that this is kept in sync with the configuration that actually happens at\n   * runtime.\n   *\n   * @example\n   * ```typescript\n   * // myToken.ts\n   * class MyToken extends Token {}\n   *\n   * // entryPoint.ts\n   * import { MyToken } from './myToken'\n   *\n   * Hooks.once('init', () => {\n   *   CONFIG.Token.objectClass = MyToken;\n   * });\n   *\n   * declare global {\n   *   interface PlaceableObjectClassConfig {\n   *     Token: typeof MyToken;\n   *   }\n   * }\n   * ```\n   */\n  //eslint-disable-next-line @typescript-eslint/no-empty-interface\n  interface PlaceableObjectClassConfig {}\n\n  /**\n   * This interface together with {@link SourceConfig} is used to configure the\n   * types of the `data`  and `data._source` properties of the\n   * {@link foundry.documents.BaseActor} and {@link foundry.documents.BaseItem}\n   * classes. System authors should use declaration merging to provide the types\n   * that match their `template.json` file. It is also very important for these\n   * types to stay in sync with the `template.json` file, otherwise unexpected\n   * runtime errors might appear.\n   *\n   * @example\n   * ```typescript\n   * interface ArmorDataSourceData {\n   *   armorValue: number;\n   * }\n   *\n   * interface ArmorDataSource {\n   *   type: 'armor';\n   *   data: ArmorDataSourceData;\n   * }\n   *\n   * interface WeaponDataSourceData {\n   *   damagePerHit: number;\n   *   attackSpeed: number;\n   * }\n   *\n   * interface WeaponDataSource {\n   *   type: 'weapon';\n   *   data: WeaponDataSourceData;\n   * }\n   *\n   * interface ArmorDataPropertiesData extends ArmorDataSourceData {\n   *   weight: number;\n   * }\n   *\n   * interface ArmorDataProperties {\n   *   type: 'armor';\n   *   data: ArmorDataPropertiesData;\n   * }\n   *\n   * interface WeaponDataPropertiesData extends WeaponDataSourceData {\n   *   damage: number;\n   * }\n   *\n   * interface WeaponDataProperties {\n   *   type: 'weapon';\n   *   data: WeaponDataPropertiesData;\n   * }\n   *\n   * type MyItemDataSource = ArmorDataSource | WeaponDataSource;\n   * type MyItemDataProperties = ArmorDataProperties | WeaponDataProperties;\n   *\n   * declare global {\n   *   interface DataConfig {\n   *     Item: MyItemDataProperties;\n   *   }\n   *\n   *   interface SourceConfig {\n   *     Item: MyItemDataSource;\n   *   }\n   * }\n   * const item = await Item.create({\n   *   name: 'Axe',\n   *   type: 'weapon',\n   *   attackSpeed: 1,\n   *   damage: 5\n   * });\n   *\n   * if(item.data.type === 'weapon') {\n   *   const damage: number = item.data.data.damage;\n   * }\n   *\n   * if(item.data._source.type === 'armor') {\n   *   const armorValue = item.data._source.data.armorValue;\n   * }\n   * ```\n   */\n  // eslint-disable-next-line @typescript-eslint/no-empty-interface\n  interface DataConfig {}\n\n  /** @see {@link DataConfig} */\n  // eslint-disable-next-line @typescript-eslint/no-empty-interface\n  interface SourceConfig {}\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-interface\n  interface FlagConfig {}\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-interface\n  interface WebRTCConfig {}\n}\n\nexport {};\n"
    ]
  