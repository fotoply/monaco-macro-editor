
    export default [
      "@pixi\\display\\index.d.ts",
      "/// <reference path=\"./global.d.ts\" />\n\nimport type { Dict } from '@pixi/utils';\r\nimport { EventEmitter } from '@pixi/utils';\r\nimport type { Filter } from '@pixi/core';\r\nimport type { IPointData } from '@pixi/math';\r\nimport type { MaskData } from '@pixi/core';\r\nimport { Matrix } from '@pixi/math';\r\nimport type { ObservablePoint } from '@pixi/math';\r\nimport { Point } from '@pixi/math';\r\nimport { Rectangle } from '@pixi/math';\r\nimport type { Renderer } from '@pixi/core';\r\nimport { Transform } from '@pixi/math';\r\n\r\n/**\r\n * 'Builder' pattern for bounds rectangles.\r\n *\r\n * This could be called an Axis-Aligned Bounding Box.\r\n * It is not an actual shape. It is a mutable thing; no 'EMPTY' or those kind of problems.\r\n * @memberof PIXI\r\n */\r\nexport declare class Bounds {\r\n    /** @default Infinity */\r\n    minX: number;\r\n    /** @default Infinity */\r\n    minY: number;\r\n    /** @default -Infinity */\r\n    maxX: number;\r\n    /** @default -Infinity */\r\n    maxY: number;\r\n    rect: Rectangle;\r\n    /**\r\n     * It is updated to _boundsID of corresponding object to keep bounds in sync with content.\r\n     * Updated from outside, thus public modifier.\r\n     */\r\n    updateID: number;\r\n    constructor();\r\n    /**\r\n     * Checks if bounds are empty.\r\n     * @returns - True if empty.\r\n     */\r\n    isEmpty(): boolean;\r\n    /** Clears the bounds and resets. */\r\n    clear(): void;\r\n    /**\r\n     * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle\r\n     * It is not guaranteed that it will return tempRect\r\n     * @param rect - Temporary object will be used if AABB is not empty\r\n     * @returns - A rectangle of the bounds\r\n     */\r\n    getRectangle(rect?: Rectangle): Rectangle;\r\n    /**\r\n     * This function should be inlined when its possible.\r\n     * @param point - The point to add.\r\n     */\r\n    addPoint(point: IPointData): void;\r\n    /**\r\n     * Adds a point, after transformed. This should be inlined when its possible.\r\n     * @param matrix\r\n     * @param point\r\n     */\r\n    addPointMatrix(matrix: Matrix, point: IPointData): void;\r\n    /**\r\n     * Adds a quad, not transformed\r\n     * @param vertices - The verts to add.\r\n     */\r\n    addQuad(vertices: Float32Array): void;\r\n    /**\r\n     * Adds sprite frame, transformed.\r\n     * @param transform - transform to apply\r\n     * @param x0 - left X of frame\r\n     * @param y0 - top Y of frame\r\n     * @param x1 - right X of frame\r\n     * @param y1 - bottom Y of frame\r\n     */\r\n    addFrame(transform: Transform, x0: number, y0: number, x1: number, y1: number): void;\r\n    /**\r\n     * Adds sprite frame, multiplied by matrix\r\n     * @param matrix - matrix to apply\r\n     * @param x0 - left X of frame\r\n     * @param y0 - top Y of frame\r\n     * @param x1 - right X of frame\r\n     * @param y1 - bottom Y of frame\r\n     */\r\n    addFrameMatrix(matrix: Matrix, x0: number, y0: number, x1: number, y1: number): void;\r\n    /**\r\n     * Adds screen vertices from array\r\n     * @param vertexData - calculated vertices\r\n     * @param beginOffset - begin offset\r\n     * @param endOffset - end offset, excluded\r\n     */\r\n    addVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number): void;\r\n    /**\r\n     * Add an array of mesh vertices\r\n     * @param transform - mesh transform\r\n     * @param vertices - mesh coordinates in array\r\n     * @param beginOffset - begin offset\r\n     * @param endOffset - end offset, excluded\r\n     */\r\n    addVertices(transform: Transform, vertices: Float32Array, beginOffset: number, endOffset: number): void;\r\n    /**\r\n     * Add an array of mesh vertices.\r\n     * @param matrix - mesh matrix\r\n     * @param vertices - mesh coordinates in array\r\n     * @param beginOffset - begin offset\r\n     * @param endOffset - end offset, excluded\r\n     * @param padX - x padding\r\n     * @param padY - y padding\r\n     */\r\n    addVerticesMatrix(matrix: Matrix, vertices: Float32Array, beginOffset: number, endOffset: number, padX?: number, padY?: number): void;\r\n    /**\r\n     * Adds other {@link Bounds}.\r\n     * @param bounds - The Bounds to be added\r\n     */\r\n    addBounds(bounds: Bounds): void;\r\n    /**\r\n     * Adds other Bounds, masked with Bounds.\r\n     * @param bounds - The Bounds to be added.\r\n     * @param mask - TODO\r\n     */\r\n    addBoundsMask(bounds: Bounds, mask: Bounds): void;\r\n    /**\r\n     * Adds other Bounds, multiplied by matrix. Bounds shouldn't be empty.\r\n     * @param bounds - other bounds\r\n     * @param matrix - multiplicator\r\n     */\r\n    addBoundsMatrix(bounds: Bounds, matrix: Matrix): void;\r\n    /**\r\n     * Adds other Bounds, masked with Rectangle.\r\n     * @param bounds - TODO\r\n     * @param area - TODO\r\n     */\r\n    addBoundsArea(bounds: Bounds, area: Rectangle): void;\r\n    /**\r\n     * Pads bounds object, making it grow in all directions.\r\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\r\n     * @param paddingX - The horizontal padding amount.\r\n     * @param paddingY - The vertical padding amount.\r\n     */\r\n    pad(paddingX?: number, paddingY?: number): void;\r\n    /**\r\n     * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)\r\n     * @param x0 - left X of frame\r\n     * @param y0 - top Y of frame\r\n     * @param x1 - right X of frame\r\n     * @param y1 - bottom Y of frame\r\n     * @param padX - padding X\r\n     * @param padY - padding Y\r\n     */\r\n    addFramePad(x0: number, y0: number, x1: number, y1: number, padX: number, padY: number): void;\r\n}\r\n\r\nexport declare interface Container extends GlobalMixins.Container, DisplayObject {\r\n}\r\n\r\n/**\r\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\r\n * rendering features like masking and filtering.\r\n *\r\n * It is the base class of all display objects that act as a container for other objects, including Graphics\r\n * and Sprite.\r\n *\r\n * ```js\r\n * import { BlurFilter } from '@pixi/filter-blur';\r\n * import { Container } from '@pixi/display';\r\n * import { Graphics } from '@pixi/graphics';\r\n * import { Sprite } from '@pixi/sprite';\r\n *\r\n * let container = new Container();\r\n * let sprite = Sprite.from(\"https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png\");\r\n *\r\n * sprite.width = 512;\r\n * sprite.height = 512;\r\n *\r\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\r\n * // is rendered.\r\n * container.addChild(sprite);\r\n *\r\n * // Blurs whatever is rendered by the container\r\n * container.filters = [new BlurFilter()];\r\n *\r\n * // Only the contents within a circle at the center should be rendered onto the screen.\r\n * container.mask = new Graphics()\r\n *  .beginFill(0xffffff)\r\n *  .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\r\n *  .endFill();\r\n * ```\r\n * @memberof PIXI\r\n */\r\nexport declare class Container extends DisplayObject {\r\n    /**\r\n     * The array of children of this container.\r\n     * @readonly\r\n     */\r\n    readonly children: DisplayObject[];\r\n    /**\r\n     * If set to true, the container will sort its children by zIndex value\r\n     * when updateTransform() is called, or manually if sortChildren() is called.\r\n     *\r\n     * This actually changes the order of elements in the array, so should be treated\r\n     * as a basic solution that is not performant compared to other solutions,\r\n     * such as @link https://github.com/pixijs/pixi-display\r\n     *\r\n     * Also be aware of that this may not work nicely with the addChildAt() function,\r\n     * as the zIndex sorting may cause the child to automatically sorted to another position.\r\n     * @see PIXI.settings.SORTABLE_CHILDREN\r\n     */\r\n    sortableChildren: boolean;\r\n    /**\r\n     * Should children be sorted by zIndex at the next updateTransform call.\r\n     *\r\n     * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\r\n     */\r\n    sortDirty: boolean;\r\n    parent: Container;\r\n    containerUpdateTransform: () => void;\r\n    protected _width: number;\r\n    protected _height: number;\r\n    constructor();\r\n    /**\r\n     * Overridable method that can be used by Container subclasses whenever the children array is modified.\r\n     * @param _length\r\n     */\r\n    protected onChildrenChange(_length?: number): void;\r\n    /**\r\n     * Adds one or more children to the container.\r\n     *\r\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\r\n     * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to add to the container\r\n     * @returns {PIXI.DisplayObject} - The first child that was added.\r\n     */\r\n    addChild<T extends DisplayObject[]>(...children: T): T[0];\r\n    /**\r\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\r\n     * @param {PIXI.DisplayObject} child - The child to add\r\n     * @param {number} index - The index to place the child in\r\n     * @returns {PIXI.DisplayObject} The child that was added.\r\n     */\r\n    addChildAt<T extends DisplayObject>(child: T, index: number): T;\r\n    /**\r\n     * Swaps the position of 2 Display Objects within this container.\r\n     * @param child - First display object to swap\r\n     * @param child2 - Second display object to swap\r\n     */\r\n    swapChildren(child: DisplayObject, child2: DisplayObject): void;\r\n    /**\r\n     * Returns the index position of a child DisplayObject instance\r\n     * @param child - The DisplayObject instance to identify\r\n     * @returns - The index position of the child display object to identify\r\n     */\r\n    getChildIndex(child: DisplayObject): number;\r\n    /**\r\n     * Changes the position of an existing child in the display object container\r\n     * @param child - The child DisplayObject instance for which you want to change the index number\r\n     * @param index - The resulting index number for the child display object\r\n     */\r\n    setChildIndex(child: DisplayObject, index: number): void;\r\n    /**\r\n     * Returns the child at the specified index\r\n     * @param index - The index to get the child at\r\n     * @returns - The child at the given index, if any.\r\n     */\r\n    getChildAt(index: number): DisplayObject;\r\n    /**\r\n     * Removes one or more children from the container.\r\n     * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to remove\r\n     * @returns {PIXI.DisplayObject} The first child that was removed.\r\n     */\r\n    removeChild<T extends DisplayObject[]>(...children: T): T[0];\r\n    /**\r\n     * Removes a child from the specified index position.\r\n     * @param index - The index to get the child from\r\n     * @returns The child that was removed.\r\n     */\r\n    removeChildAt(index: number): DisplayObject;\r\n    /**\r\n     * Removes all children from this container that are within the begin and end indexes.\r\n     * @param beginIndex - The beginning position.\r\n     * @param endIndex - The ending position. Default value is size of the container.\r\n     * @returns - List of removed children\r\n     */\r\n    removeChildren(beginIndex?: number, endIndex?: number): DisplayObject[];\r\n    /** Sorts children by zIndex. Previous order is maintained for 2 children with the same zIndex. */\r\n    sortChildren(): void;\r\n    /** Updates the transform on all children of this container for rendering. */\r\n    updateTransform(): void;\r\n    /**\r\n     * Recalculates the bounds of the container.\r\n     *\r\n     * This implementation will automatically fit the children's bounds into the calculation. Each child's bounds\r\n     * is limited to its mask's bounds or filterArea, if any is applied.\r\n     */\r\n    calculateBounds(): void;\r\n    /**\r\n     * Retrieves the local bounds of the displayObject as a rectangle object.\r\n     *\r\n     * Calling `getLocalBounds` may invalidate the `_bounds` of the whole subtree below. If using it inside a render()\r\n     * call, it is advised to call `getBounds()` immediately after to recalculate the world bounds of the subtree.\r\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\r\n     * @param skipChildrenUpdate - Setting to `true` will stop re-calculation of children transforms,\r\n     *  it was default behaviour of pixi 4.0-5.2 and caused many problems to users.\r\n     * @returns - The rectangular bounding area.\r\n     */\r\n    getLocalBounds(rect?: Rectangle, skipChildrenUpdate?: boolean): Rectangle;\r\n    /**\r\n     * Recalculates the content bounds of this object. This should be overriden to\r\n     * calculate the bounds of this specific object (not including children).\r\n     * @protected\r\n     */\r\n    protected _calculateBounds(): void;\r\n    /**\r\n     * Renders this object and its children with culling.\r\n     * @protected\r\n     * @param {PIXI.Renderer} renderer - The renderer\r\n     */\r\n    protected _renderWithCulling(renderer: Renderer): void;\r\n    /**\r\n     * Renders the object using the WebGL renderer.\r\n     *\r\n     * The [_render]{@link PIXI.Container#_render} method is be overriden for rendering the contents of the\r\n     * container itself. This `render` method will invoke it, and also invoke the `render` methods of all\r\n     * children afterward.\r\n     *\r\n     * If `renderable` or `visible` is false or if `worldAlpha` is not positive or if `cullable` is true and\r\n     * the bounds of this object are out of frame, this implementation will entirely skip rendering.\r\n     * See {@link PIXI.DisplayObject} for choosing between `renderable` or `visible`. Generally,\r\n     * setting alpha to zero is not recommended for purely skipping rendering.\r\n     *\r\n     * When your scene becomes large (especially when it is larger than can be viewed in a single screen), it is\r\n     * advised to employ **culling** to automatically skip rendering objects outside of the current screen.\r\n     * See [cullable]{@link PIXI.DisplayObject#cullable} and [cullArea]{@link PIXI.DisplayObject#cullArea}.\r\n     * Other culling methods might be better suited for a large number static objects; see\r\n     * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} and\r\n     * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull}.\r\n     *\r\n     * The [renderAdvanced]{@link PIXI.Container#renderAdvanced} method is internally used when when masking or\r\n     * filtering is applied on a container. This does, however, break batching and can affect performance when\r\n     * masking and filtering is applied extensively throughout the scene graph.\r\n     * @param renderer - The renderer\r\n     */\r\n    render(renderer: Renderer): void;\r\n    /**\r\n     * Render the object using the WebGL renderer and advanced features.\r\n     * @param renderer - The renderer\r\n     */\r\n    protected renderAdvanced(renderer: Renderer): void;\r\n    /**\r\n     * To be overridden by the subclasses.\r\n     * @param _renderer - The renderer\r\n     */\r\n    protected _render(_renderer: Renderer): void;\r\n    /**\r\n     * Removes all internal references and listeners as well as removes children from the display list.\r\n     * Do not use a Container after calling `destroy`.\r\n     * @param options - Options parameter. A boolean will act as if all options\r\n     *  have been set to that value\r\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\r\n     *  method called as well. 'options' will be passed on to those calls.\r\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\r\n     *  Should it destroy the texture of the child sprite\r\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\r\n     *  Should it destroy the base texture of the child sprite\r\n     */\r\n    destroy(options?: IDestroyOptions | boolean): void;\r\n    /** The width of the Container, setting this will actually modify the scale to achieve the value set. */\r\n    get width(): number;\r\n    set width(value: number);\r\n    /** The height of the Container, setting this will actually modify the scale to achieve the value set. */\r\n    get height(): number;\r\n    set height(value: number);\r\n}\r\n\r\nexport declare interface DisplayObject extends Omit<GlobalMixins.DisplayObject, keyof EventEmitter>, EventEmitter {\r\n}\r\n\r\n/**\r\n * The base class for all objects that are rendered on the screen.\r\n *\r\n * This is an abstract class and can not be used on its own; rather it should be extended.\r\n *\r\n * ## Display objects implemented in PixiJS\r\n *\r\n * | Display Object                  | Description                                                           |\r\n * | ------------------------------- | --------------------------------------------------------------------- |\r\n * | {@link PIXI.Container}          | Adds support for `children` to DisplayObject                          |\r\n * | {@link PIXI.Graphics}           | Shape-drawing display object similar to the Canvas API                |\r\n * | {@link PIXI.Sprite}             | Draws textures (i.e. images)                                          |\r\n * | {@link PIXI.Text}               | Draws text using the Canvas API internally                            |\r\n * | {@link PIXI.BitmapText}         | More scaleable solution for text rendering, reusing glyph textures    |\r\n * | {@link PIXI.TilingSprite}       | Draws textures/images in a tiled fashion                              |\r\n * | {@link PIXI.AnimatedSprite}     | Draws an animation of multiple images                                 |\r\n * | {@link PIXI.Mesh}               | Provides a lower-level API for drawing meshes with custom data        |\r\n * | {@link PIXI.NineSlicePlane}     | Mesh-related                                                          |\r\n * | {@link PIXI.SimpleMesh}         | v4-compatible mesh                                                    |\r\n * | {@link PIXI.SimplePlane}        | Mesh-related                                                          |\r\n * | {@link PIXI.SimpleRope}         | Mesh-related                                                          |\r\n *\r\n * ## Transforms\r\n *\r\n * The [transform]{@link DisplayObject#transform} of a display object describes the projection from its\r\n * local coordinate space to its parent's local coordinate space. The following properties are derived\r\n * from the transform:\r\n *\r\n * <table>\r\n *   <thead>\r\n *     <tr>\r\n *       <th>Property</th>\r\n *       <th>Description</th>\r\n *     </tr>\r\n *   </thead>\r\n *   <tbody>\r\n *     <tr>\r\n *       <td>[pivot]{@link PIXI.DisplayObject#pivot}</td>\r\n *       <td>\r\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\r\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\r\n *         rotation, scaling, and skewing.\r\n *       </td>\r\n *     </tr>\r\n *     <tr>\r\n *       <td>[position]{@link PIXI.DisplayObject#position}</td>\r\n *       <td>\r\n *         Translation. This is the position of the [pivot]{@link PIXI.DisplayObject#pivot} in the parent's local\r\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\r\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\r\n *       </td>\r\n *     </tr>\r\n *     <tr>\r\n *       <td>[scale]{@link PIXI.DisplayObject#scale}</td>\r\n *       <td>\r\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\r\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\r\n *         of scaling is the [pivot]{@link PIXI.DisplayObject#pivot}.\r\n *       </td>\r\n *     </tr>\r\n *     <tr>\r\n *       <td>[rotation]{@link PIXI.DisplayObject#rotation}</td>\r\n *       <td>\r\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\r\n *       </td>\r\n *     </tr>\r\n *     <tr>\r\n *       <td>[skew]{@link PIXI.DisplayObject#skew}</td>\r\n *       <td>\r\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\r\n *         <p>\r\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\r\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\r\n *         ⍺ and \"skew.y\" is β, then the line x = 0 will be rotated by ⍺ (y = -x*cot⍺) and the line y = 0 will be\r\n *         rotated by β (y = x*tanβ). A line y = x*tanϴ (i.e. a line at angle ϴ to the x-axis in local-space) will\r\n *         be rotated by an angle between ⍺ and β.\r\n *         </p>\r\n *         <p>\r\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\r\n *         a rotation. Indeed, if \"skew.x\" = -ϴ and \"skew.y\" = ϴ, it will produce an equivalent of \"rotation\" = ϴ.\r\n *         </p>\r\n *         <p>\r\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are communtative operations. Indeed,\r\n *         because rotation is essentially a careful combination of the two.\r\n *         </p>\r\n *       </td>\r\n *     </tr>\r\n *     <tr>\r\n *       <td>angle</td>\r\n *       <td>Rotation. This is an alias for [rotation]{@link PIXI.DisplayObject#rotation}, but in degrees.</td>\r\n *     </tr>\r\n *     <tr>\r\n *       <td>x</td>\r\n *       <td>Translation. This is an alias for position.x!</td>\r\n *     </tr>\r\n *     <tr>\r\n *       <td>y</td>\r\n *       <td>Translation. This is an alias for position.y!</td>\r\n *     </tr>\r\n *     <tr>\r\n *       <td>width</td>\r\n *       <td>\r\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The width property calculates scale.x by dividing\r\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\r\n *         is no concept of user-defined width.\r\n *       </td>\r\n *     </tr>\r\n *     <tr>\r\n *       <td>height</td>\r\n *       <td>\r\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The height property calculates scale.y by dividing\r\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\r\n *         is no concept of user-defined height.\r\n *       </td>\r\n *     </tr>\r\n *   </tbody>\r\n * </table>\r\n *\r\n * ## Bounds\r\n *\r\n * The bounds of a display object is defined by the minimum axis-aligned rectangle in world space that can fit\r\n * around it. The abstract `calculateBounds` method is responsible for providing it (and it should use the\r\n * `worldTransform` to calculate in world space).\r\n *\r\n * There are a few additional types of bounding boxes:\r\n *\r\n * | Bounds                | Description                                                                              |\r\n * | --------------------- | ---------------------------------------------------------------------------------------- |\r\n * | World Bounds          | This is synonymous is the regular bounds described above. See `getBounds()`.             |\r\n * | Local Bounds          | This the axis-aligned bounding box in the parent's local space. See `getLocalBounds()`.  |\r\n * | Render Bounds         | The bounds, but including extra rendering effects like filter padding.                   |\r\n * | Projected Bounds      | The bounds of the projected display object onto the screen. Usually equals world bounds. |\r\n * | Relative Bounds       | The bounds of a display object when projected onto a ancestor's (or parent's) space.     |\r\n * | Natural Bounds        | The bounds of an object in its own local space (not parent's space, like in local bounds)|\r\n * | Content Bounds        | The natural bounds when excluding all children of a `Container`.                         |\r\n *\r\n * ### calculateBounds\r\n *\r\n * [Container]{@link Container} already implements `calculateBounds` in a manner that includes children.\r\n *\r\n * But for a non-Container display object, the `calculateBounds` method must be overridden in order for `getBounds` and\r\n * `getLocalBounds` to work. This method must write the bounds into `this._bounds`.\r\n *\r\n * Generally, the following technique works for most simple cases: take the list of points\r\n * forming the \"hull\" of the object (i.e. outline of the object's shape), and then add them\r\n * using {@link PIXI.Bounds#addPointMatrix}.\r\n *\r\n * ```js\r\n * calculateBounds(): void\r\n * {\r\n *     const points = [...];\r\n *\r\n *     for (let i = 0, j = points.length; i < j; i++)\r\n *     {\r\n *         this._bounds.addPointMatrix(this.worldTransform, points[i]);\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * You can optimize this for a large number of points by using {@link PIXI.Bounds#addVerticesMatrix} to pass them\r\n * in one array together.\r\n *\r\n * ## Alpha\r\n *\r\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\r\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\r\n * applied on any ancestor further up the chain).\r\n *\r\n * The alpha with which the display object will be rendered is called the [worldAlpha]{@link PIXI.DisplayObject#worldAlpha}.\r\n *\r\n * ## Renderable vs Visible\r\n *\r\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\r\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\r\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\r\n * be calculated.\r\n *\r\n * It is recommended that applications use the `renderable` property for culling. See\r\n * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} or\r\n * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull} for more details.\r\n *\r\n * Otherwise, to prevent an object from rendering in the general-purpose sense - `visible` is the property to use. This\r\n * one is also better in terms of performance.\r\n * @memberof PIXI\r\n */\r\nexport declare abstract class DisplayObject extends EventEmitter {\r\n    abstract sortDirty: boolean;\r\n    /** The display object container that contains this display object. */\r\n    parent: Container;\r\n    /**\r\n     * The multiplied alpha of the displayObject.\r\n     * @readonly\r\n     */\r\n    worldAlpha: number;\r\n    /**\r\n     * World transform and local transform of this object.\r\n     * This will become read-only later, please do not assign anything there unless you know what are you doing.\r\n     */\r\n    transform: Transform;\r\n    /** The opacity of the object. */\r\n    alpha: number;\r\n    /**\r\n     * The visibility of the object. If false the object will not be drawn, and\r\n     * the updateTransform function will not be called.\r\n     *\r\n     * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.\r\n     */\r\n    visible: boolean;\r\n    /**\r\n     * Can this object be rendered, if false the object will not be drawn but the updateTransform\r\n     * methods will still be called.\r\n     *\r\n     * Only affects recursive calls from parent. You can ask for bounds manually.\r\n     */\r\n    renderable: boolean;\r\n    /**\r\n     * Should this object be rendered if the bounds of this object are out of frame?\r\n     *\r\n     * Culling has no effect on whether updateTransform is called.\r\n     */\r\n    cullable: boolean;\r\n    /**\r\n     * If set, this shape is used for culling instead of the bounds of this object.\r\n     * It can improve the culling performance of objects with many children.\r\n     * The culling area is defined in local space.\r\n     */\r\n    cullArea: Rectangle;\r\n    /**\r\n     * The area the filter is applied to. This is used as more of an optimization\r\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\r\n     *\r\n     * Also works as an interaction mask.\r\n     */\r\n    filterArea: Rectangle;\r\n    /**\r\n     * Sets the filters for the displayObject.\r\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\r\n     * To remove filters simply set this property to `'null'`.\r\n     */\r\n    filters: Filter[] | null;\r\n    /** Used to fast check if a sprite is.. a sprite! */\r\n    isSprite: boolean;\r\n    /** Does any other displayObject use this object as a mask? */\r\n    isMask: boolean;\r\n    /**\r\n     * Which index in the children array the display component was before the previous zIndex sort.\r\n     * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.\r\n     * @protected\r\n     */\r\n    _lastSortedIndex: number;\r\n    /**\r\n     * The original, cached mask of the object.\r\n     * @protected\r\n     */\r\n    _mask: Container | MaskData;\r\n    /** The bounds object, this is used to calculate and store the bounds of the displayObject. */\r\n    _bounds: Bounds;\r\n    /** Local bounds object, swapped with `_bounds` when using `getLocalBounds()`. */\r\n    _localBounds: Bounds;\r\n    /**\r\n     * The zIndex of the displayObject.\r\n     * A higher value will mean it will be rendered on top of other displayObjects within the same container.\r\n     * @protected\r\n     */\r\n    protected _zIndex: number;\r\n    /**\r\n     * Currently enabled filters.\r\n     * @protected\r\n     */\r\n    protected _enabledFilters: Filter[];\r\n    /** Flags the cached bounds as dirty. */\r\n    protected _boundsID: number;\r\n    /** Cache of this display-object's bounds-rectangle. */\r\n    protected _boundsRect: Rectangle;\r\n    /** Cache of this display-object's local-bounds rectangle. */\r\n    protected _localBoundsRect: Rectangle;\r\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\r\n    protected _destroyed: boolean;\r\n    /** The number of times this object is used as a mask by another object. */\r\n    private _maskRefCount;\r\n    private tempDisplayObjectParent;\r\n    displayObjectUpdateTransform: () => void;\r\n    /**\r\n     * Mixes all enumerable properties and methods from a source object to DisplayObject.\r\n     * @param source - The source of properties and methods to mix in.\r\n     */\r\n    static mixin(source: Dict<any>): void;\r\n    constructor();\r\n    /**\r\n     * Fired when this DisplayObject is added to a Container.\r\n     * @instance\r\n     * @event added\r\n     * @param {PIXI.Container} container - The container added to.\r\n     */\r\n    /**\r\n     * Fired when this DisplayObject is removed from a Container.\r\n     * @instance\r\n     * @event removed\r\n     * @param {PIXI.Container} container - The container removed from.\r\n     */\r\n    /**\r\n     * Fired when this DisplayObject is destroyed. This event is emitted once\r\n     * destroy is finished.\r\n     * @instance\r\n     * @event destroyed\r\n     */\r\n    /** Readonly flag for destroyed display objects. */\r\n    get destroyed(): boolean;\r\n    /** Recalculates the bounds of the display object. */\r\n    abstract calculateBounds(): void;\r\n    abstract removeChild(child: DisplayObject): void;\r\n    /**\r\n     * Renders the object using the WebGL renderer.\r\n     * @param renderer - The renderer.\r\n     */\r\n    abstract render(renderer: Renderer): void;\r\n    /** Recursively updates transform of all objects from the root to this one internal function for toLocal() */\r\n    protected _recursivePostUpdateTransform(): void;\r\n    /** Updates the object transform for rendering. TODO - Optimization pass! */\r\n    updateTransform(): void;\r\n    /**\r\n     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link PIXI.Rectangle}.\r\n     *\r\n     * This method is expensive on containers with a large subtree (like the stage). This is because the bounds\r\n     * of a container depend on its children's bounds, which recursively causes all bounds in the subtree to\r\n     * be recalculated. The upside, however, is that calling `getBounds` once on a container will indeed update\r\n     * the bounds of all children (the whole subtree, in fact). This side effect should be exploited by using\r\n     * `displayObject._bounds.getRectangle()` when traversing through all the bounds in a scene graph. Otherwise,\r\n     * calling `getBounds` on each object in a subtree will cause the total cost to increase quadratically as\r\n     * its height increases.\r\n     *\r\n     * The transforms of all objects in a container's **subtree** and of all **ancestors** are updated.\r\n     * The world bounds of all display objects in a container's **subtree** will also be recalculated.\r\n     *\r\n     * The `_bounds` object stores the last calculation of the bounds. You can use to entirely skip bounds\r\n     * calculation if needed.\r\n     *\r\n     * ```js\r\n     * const lastCalculatedBounds = displayObject._bounds.getRectangle(optionalRect);\r\n     * ```\r\n     *\r\n     * Do know that usage of `getLocalBounds` can corrupt the `_bounds` of children (the whole subtree, actually). This\r\n     * is a known issue that has not been solved. See [getLocalBounds]{@link PIXI.DisplayObject#getLocalBounds} for more\r\n     * details.\r\n     *\r\n     * `getBounds` should be called with `skipUpdate` equal to `true` in a render() call. This is because the transforms\r\n     * are guaranteed to be update-to-date. In fact, recalculating inside a render() call may cause corruption in certain\r\n     * cases.\r\n     * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\r\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\r\n     *  nice performance boost.\r\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\r\n     * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\r\n     */\r\n    getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle;\r\n    /**\r\n     * Retrieves the local bounds of the displayObject as a rectangle object.\r\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\r\n     * @returns - The rectangular bounding area.\r\n     */\r\n    getLocalBounds(rect?: Rectangle): Rectangle;\r\n    /**\r\n     * Calculates the global position of the display object.\r\n     * @param position - The world origin to calculate from.\r\n     * @param point - A Point object in which to store the value, optional\r\n     *  (otherwise will create a new Point).\r\n     * @param skipUpdate - Should we skip the update transform.\r\n     * @returns - A point object representing the position of this object.\r\n     */\r\n    toGlobal<P extends IPointData = Point>(position: IPointData, point?: P, skipUpdate?: boolean): P;\r\n    /**\r\n     * Calculates the local position of the display object relative to another point.\r\n     * @param position - The world origin to calculate from.\r\n     * @param from - The DisplayObject to calculate the global position from.\r\n     * @param point - A Point object in which to store the value, optional\r\n     *  (otherwise will create a new Point).\r\n     * @param skipUpdate - Should we skip the update transform\r\n     * @returns - A point object representing the position of this object\r\n     */\r\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean): P;\r\n    /**\r\n     * Set the parent Container of this DisplayObject.\r\n     * @param container - The Container to add this DisplayObject to.\r\n     * @returns - The Container that this DisplayObject was added to.\r\n     */\r\n    setParent(container: Container): Container;\r\n    /**\r\n     * Convenience function to set the position, scale, skew and pivot at once.\r\n     * @param x - The X position\r\n     * @param y - The Y position\r\n     * @param scaleX - The X scale value\r\n     * @param scaleY - The Y scale value\r\n     * @param rotation - The rotation\r\n     * @param skewX - The X skew value\r\n     * @param skewY - The Y skew value\r\n     * @param pivotX - The X pivot value\r\n     * @param pivotY - The Y pivot value\r\n     * @returns - The DisplayObject instance\r\n     */\r\n    setTransform(x?: number, y?: number, scaleX?: number, scaleY?: number, rotation?: number, skewX?: number, skewY?: number, pivotX?: number, pivotY?: number): this;\r\n    /**\r\n     * Base destroy method for generic display objects. This will automatically\r\n     * remove the display object from its parent Container as well as remove\r\n     * all current event listeners and internal references. Do not use a DisplayObject\r\n     * after calling `destroy()`.\r\n     * @param _options\r\n     */\r\n    destroy(_options?: IDestroyOptions | boolean): void;\r\n    /**\r\n     * @protected\r\n     * @member {PIXI.Container}\r\n     */\r\n    get _tempDisplayObjectParent(): TemporaryDisplayObject;\r\n    /**\r\n     * Used in Renderer, cacheAsBitmap and other places where you call an `updateTransform` on root\r\n     *\r\n     * ```\r\n     * const cacheParent = elem.enableTempParent();\r\n     * elem.updateTransform();\r\n     * elem.disableTempParent(cacheParent);\r\n     * ```\r\n     * @returns - current parent\r\n     */\r\n    enableTempParent(): Container;\r\n    /**\r\n     * Pair method for `enableTempParent`\r\n     * @param cacheParent - Actual parent of element\r\n     */\r\n    disableTempParent(cacheParent: Container): void;\r\n    /**\r\n     * The position of the displayObject on the x axis relative to the local coordinates of the parent.\r\n     * An alias to position.x\r\n     */\r\n    get x(): number;\r\n    set x(value: number);\r\n    /**\r\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\r\n     * An alias to position.y\r\n     */\r\n    get y(): number;\r\n    set y(value: number);\r\n    /**\r\n     * Current transform of the object based on world (parent) factors.\r\n     * @readonly\r\n     */\r\n    get worldTransform(): Matrix;\r\n    /**\r\n     * Current transform of the object based on local factors: position, scale, other stuff.\r\n     * @readonly\r\n     */\r\n    get localTransform(): Matrix;\r\n    /**\r\n     * The coordinate of the object relative to the local coordinates of the parent.\r\n     * @since 4.0.0\r\n     */\r\n    get position(): ObservablePoint;\r\n    set position(value: IPointData);\r\n    /**\r\n     * The scale factors of this object along the local coordinate axes.\r\n     *\r\n     * The default scale is (1, 1).\r\n     * @since 4.0.0\r\n     */\r\n    get scale(): ObservablePoint;\r\n    set scale(value: IPointData);\r\n    /**\r\n     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\r\n     * is the projection of `pivot` in the parent's local space.\r\n     *\r\n     * By default, the pivot is the origin (0, 0).\r\n     * @since 4.0.0\r\n     */\r\n    get pivot(): ObservablePoint;\r\n    set pivot(value: IPointData);\r\n    /**\r\n     * The skew factor for the object in radians.\r\n     * @since 4.0.0\r\n     */\r\n    get skew(): ObservablePoint;\r\n    set skew(value: IPointData);\r\n    /**\r\n     * The rotation of the object in radians.\r\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\r\n     */\r\n    get rotation(): number;\r\n    set rotation(value: number);\r\n    /**\r\n     * The angle of the object in degrees.\r\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\r\n     */\r\n    get angle(): number;\r\n    set angle(value: number);\r\n    /**\r\n     * The zIndex of the displayObject.\r\n     *\r\n     * If a container has the sortableChildren property set to true, children will be automatically\r\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\r\n     * and thus rendered on top of other display objects within the same container.\r\n     * @see PIXI.Container#sortableChildren\r\n     */\r\n    get zIndex(): number;\r\n    set zIndex(value: number);\r\n    /**\r\n     * Indicates if the object is globally visible.\r\n     * @readonly\r\n     */\r\n    get worldVisible(): boolean;\r\n    /**\r\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\r\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\r\n     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\r\n     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\r\n     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\r\n     * To remove a mask, set this property to `null`.\r\n     *\r\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\r\n     * @example\r\n     * const graphics = new PIXI.Graphics();\r\n     * graphics.beginFill(0xFF3300);\r\n     * graphics.drawRect(50, 250, 100, 100);\r\n     * graphics.endFill();\r\n     *\r\n     * const sprite = new PIXI.Sprite(texture);\r\n     * sprite.mask = graphics;\r\n     * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\r\n     */\r\n    get mask(): Container | MaskData | null;\r\n    set mask(value: Container | MaskData | null);\r\n}\r\n\r\nexport declare interface IDestroyOptions {\r\n    children?: boolean;\r\n    texture?: boolean;\r\n    baseTexture?: boolean;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport declare class TemporaryDisplayObject extends DisplayObject {\r\n    calculateBounds: () => null;\r\n    removeChild: (child: DisplayObject) => null;\r\n    render: (renderer: Renderer) => null;\r\n    sortDirty: boolean;\r\n}\r\n\r\nexport { }\r\n"
    ]
  