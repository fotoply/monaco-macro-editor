
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\common\\utils\\geometry.mjs.d.ts",
      "/**\n * Determine the relative orientation of three points in two-dimensional space.\n * The result is also an approximation of twice the signed area of the triangle defined by the three points.\n * This method is fast - but not robust against issues of floating point precision. Best used with integer coordinates.\n * Adapted from https://github.com/mourner/robust-predicates\n *\n * @param a - An endpoint of segment AB, relative to which point C is tested\n * @param b - An endpoint of segment AB, relative to which point C is tested\n * @param c - A point that is tested relative to segment AB\n *\n * @returns The relative orientation of points A, B, and C\n *          A positive value if the points are in counter-clockwise order (C lies to the left of AB)\n *          A negative value if the points are in clockwise order (C lies to the right of AB)\n *          Zero if the points A, B, and C are collinear.\n */\nexport function orient2dFast(a: Point, b: Point, c: Point): number;\n\n/**\n * Quickly test whether the line segment AB intersects with the line segment CD.\n * This method does not determine the point of intersection, for that use lineLineIntersection\n *\n * @param a - The first endpoint of segment AB\n * @param b - The second endpoint of segment AB\n * @param c - The first endpoint of segment CD\n * @param d - The second endpoint of segment CD\n *\n * @returns Do the line segments intersect?\n */\nexport function lineSegmentIntersects(a: Point, b: Point, c: Point, d: Point): boolean;\n\ninterface LineIntersection {\n  /** The x-coordinate of intersection */\n  x: number;\n\n  /** The y-coordinate of intersection */\n  y: number;\n\n  /** The vector distance from A to B on segment AB */\n  t0: number;\n\n  /** The vector distance from C to D on segment CD */\n  t1?: number;\n}\n\n/**\n * An internal helper method for computing the intersection between two infinite-length lines.\n * Adapted from http://paulbourke.net/geometry/pointlineplane/\n *\n * @param a - The first endpoint of segment AB\n * @param b - The second endpoint of segment AB\n * @param c - The first endpoint of segment CD\n * @param d - The second endpoint of segment CD\n *\n * @returns An intersection point, or null if no intersection occurred\n */\nexport function lineLineIntersection(a: Point, b: Point, c: Point, d: Point): LineIntersection | null;\n\n/**\n * An internal helper method for computing the intersection between two finite line segments.\n * Adapted from http://paulbourke.net/geometry/pointlineplane/\n *\n * @param a       - The first endpoint of segment AB\n * @param b       - The second endpoint of segment AB\n * @param c       - The first endpoint of segment CD\n * @param d       - The second endpoint of segment CD\n * @param epsilon - A small epsilon which defines a tolerance for near-equality\n *                  (default: `1e-8`)\n *\n * @returns An intersection point, or null if no intersection occurred\n */\nexport function lineSegmentIntersection(\n  a: Point,\n  b: Point,\n  c: Point,\n  d: Point,\n  epsilon?: number\n): LineIntersection | null;\n\ninterface LineCircleIntersection {\n  /** Is point A inside the circle? */\n  aInside: boolean;\n\n  /** Is point B inside the circle? */\n  bInside: boolean;\n\n  /** Is the segment AB contained within the circle? */\n  contained: boolean;\n\n  /** Is the segment AB fully outside the circle? */\n  outside: boolean;\n\n  /** Is the segment AB tangent to the circle? */\n  tangent: boolean;\n\n  /** Intersection points: zero, one, or two */\n  intersections: [number] | [number, number] | [number, number, number];\n}\n\n/**\n * Determine the intersection between a candidate wall and the circular radius of the polygon.\n *\n * @param a       - The initial vertex of the candidate edge\n * @param b       - The second vertex of the candidate edge\n * @param center  - The center of the bounding circle\n * @param radius  - The radius of the bounding circle\n * @param epsilon - A small tolerance for floating point precision\n *                  (default: `1e-8`)\n *\n * @returns The intersection of the segment AB with the circle\n */\nexport function lineCircleIntersection(\n  a: Point,\n  b: Point,\n  center: Point,\n  radius: number,\n  epsilon?: number\n): LineCircleIntersection;\n\n/**\n * Identify the point closest to C on segment AB\n *\n * @param c - The reference point C\n * @param a - Point A on segment AB\n * @param b - Point B on segment AB\n *\n * @returns The closest point to C on segment AB\n */\nexport function closestPointToSegment(c: Point, a: Point, b: Point): Point;\n\n/**\n * Determine the points of intersection between a line segment (p0,p1) and a circle.\n * There will be zero, one, or two intersections\n * See https://math.stackexchange.com/a/311956\n *\n * @param p0      - The initial point of the line segment\n * @param p1      - The terminal point of the line segment\n * @param center  - The center of the circle\n * @param radius  - The radius of the circle\n * @param epsilon - A small tolerance for floating point precision\n *                  (default: `0`)\n */\nexport function quadraticIntersection(\n  p0: Point,\n  p1: Point,\n  center: Point,\n  radius: number,\n  epsilon?: number\n): { x: number; y: number }[];\n"
    ]
  