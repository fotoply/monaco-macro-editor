
    export default [
      "@pixi\\graphics\\index.d.ts",
      "/// <reference path=\"./global.d.ts\" />\n\nimport { BatchDrawCall } from '@pixi/core';\r\nimport type { BatchDrawCall as BatchDrawCall_2 } from '@pixi/core/';\r\nimport { BatchGeometry } from '@pixi/core';\r\nimport { BLEND_MODES } from '@pixi/constants';\r\nimport { Bounds } from '@pixi/display';\r\nimport type { Circle } from '@pixi/math';\r\nimport { Container } from '@pixi/display';\r\nimport type { Ellipse } from '@pixi/math';\r\nimport type { IDestroyOptions } from '@pixi/display';\r\nimport type { IPointData } from '@pixi/math';\r\nimport type { IShape } from '@pixi/math';\r\nimport { Matrix } from '@pixi/math';\r\nimport { Point } from '@pixi/math';\r\nimport { Polygon } from '@pixi/math';\r\nimport type { Rectangle } from '@pixi/math';\r\nimport { Renderer } from '@pixi/core';\r\nimport type { RoundedRectangle } from '@pixi/math';\r\nimport { Shader } from '@pixi/core';\r\nimport type { SHAPES } from '@pixi/math';\r\nimport { Texture } from '@pixi/core';\r\n\r\n/**\r\n * Utilities for arc curves.\r\n * @private\r\n */\r\ndeclare class ArcUtils {\r\n    /**\r\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\r\n     *\r\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\r\n     * @private\r\n     * @param x1 - The x-coordinate of the beginning of the arc\r\n     * @param y1 - The y-coordinate of the beginning of the arc\r\n     * @param x2 - The x-coordinate of the end of the arc\r\n     * @param y2 - The y-coordinate of the end of the arc\r\n     * @param radius - The radius of the arc\r\n     * @param points -\r\n     * @returns - If the arc length is valid, return center of circle, radius and other info otherwise `null`.\r\n     */\r\n    static curveTo(x1: number, y1: number, x2: number, y2: number, radius: number, points: Array<number>): IArcLikeShape;\r\n    /**\r\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\r\n     * @private\r\n     * @param _startX - Start x location of arc\r\n     * @param _startY - Start y location of arc\r\n     * @param cx - The x-coordinate of the center of the circle\r\n     * @param cy - The y-coordinate of the center of the circle\r\n     * @param radius - The radius of the circle\r\n     * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\r\n     *  of the arc's circle)\r\n     * @param endAngle - The ending angle, in radians\r\n     * @param _anticlockwise - Specifies whether the drawing should be\r\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\r\n     *  indicates counter-clockwise.\r\n     * @param points - Collection of points to add to\r\n     */\r\n    static arc(_startX: number, _startY: number, cx: number, cy: number, radius: number, startAngle: number, endAngle: number, _anticlockwise: boolean, points: Array<number>): void;\r\n}\r\n\r\n/**\r\n * A structure to hold interim batch objects for Graphics.\r\n * @memberof PIXI.graphicsUtils\r\n */\r\ndeclare class BatchPart {\r\n    style: LineStyle | FillStyle;\r\n    start: number;\r\n    size: number;\r\n    attribStart: number;\r\n    attribSize: number;\r\n    constructor();\r\n    /**\r\n     * Begin batch part.\r\n     * @param style\r\n     * @param startIndex\r\n     * @param attribStart\r\n     */\r\n    begin(style: LineStyle | FillStyle, startIndex: number, attribStart: number): void;\r\n    /**\r\n     * End batch part.\r\n     * @param endIndex\r\n     * @param endAttrib\r\n     */\r\n    end(endIndex: number, endAttrib: number): void;\r\n    reset(): void;\r\n}\r\n\r\n/**\r\n * Utilities for bezier curves\r\n * @private\r\n */\r\ndeclare class BezierUtils {\r\n    /**\r\n     * Calculate length of bezier curve.\r\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\r\n     * Therefore numerical solution is used.\r\n     * @private\r\n     * @param fromX - Starting point x\r\n     * @param fromY - Starting point y\r\n     * @param cpX - Control point x\r\n     * @param cpY - Control point y\r\n     * @param cpX2 - Second Control point x\r\n     * @param cpY2 - Second Control point y\r\n     * @param toX - Destination point x\r\n     * @param toY - Destination point y\r\n     * @returns - Length of bezier curve\r\n     */\r\n    static curveLength(fromX: number, fromY: number, cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): number;\r\n    /**\r\n     * Calculate the points for a bezier curve and then draws it.\r\n     *\r\n     * Ignored from docs since it is not directly exposed.\r\n     * @ignore\r\n     * @param cpX - Control point x\r\n     * @param cpY - Control point y\r\n     * @param cpX2 - Second Control point x\r\n     * @param cpY2 - Second Control point y\r\n     * @param toX - Destination point x\r\n     * @param toY - Destination point y\r\n     * @param points - Path array to push points into\r\n     */\r\n    static curveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number, points: Array<number>): void;\r\n}\r\n\r\n/**\r\n * Builds a line to draw\r\n *\r\n * Ignored from docs since it is not directly exposed.\r\n * @ignore\r\n * @private\r\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\r\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\r\n */\r\ndeclare function buildLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void;\r\n\r\n/**\r\n * Fill style object for Graphics.\r\n * @memberof PIXI\r\n */\r\nexport declare class FillStyle {\r\n    /**\r\n     * The hex color value used when coloring the Graphics object.\r\n     * @default 0xFFFFFF\r\n     */\r\n    color: number;\r\n    /** The alpha value used when filling the Graphics object. */\r\n    alpha: number;\r\n    /**\r\n     * The texture to be used for the fill.\r\n     * @default 0\r\n     */\r\n    texture: Texture;\r\n    /**\r\n     * The transform applied to the texture.\r\n     * @default null\r\n     */\r\n    matrix: Matrix;\r\n    /** If the current fill is visible. */\r\n    visible: boolean;\r\n    constructor();\r\n    /** Clones the object */\r\n    clone(): FillStyle;\r\n    /** Reset */\r\n    reset(): void;\r\n    /** Destroy and don't use after this. */\r\n    destroy(): void;\r\n}\r\n\r\nexport declare interface Graphics extends GlobalMixins.Graphics, Container {\r\n}\r\n\r\n/**\r\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\r\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\r\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\r\n *\r\n * Please note that due to legacy naming conventions, the behavior of some functions in this class\r\n * can be confusing.  Each call to `drawRect()`, `drawPolygon()`, etc. actually stores that primitive\r\n * in the Geometry class's GraphicsGeometry object for later use in rendering or hit testing - the\r\n * functions do not directly draw anything to the screen.  Similarly, the `clear()` function doesn't\r\n * change the screen, it simply resets the list of primitives, which can be useful if you want to\r\n * rebuild the contents of an existing Graphics object.\r\n *\r\n * Once a GraphicsGeometry list is built, you can re-use it in other Geometry objects as\r\n * an optimization, by passing it into a new Geometry object's constructor.  Because of this\r\n * ability, it's important to call `destroy()` on Geometry objects once you are done with them, to\r\n * properly dereference each GraphicsGeometry and prevent memory leaks.\r\n * @memberof PIXI\r\n */\r\nexport declare class Graphics extends Container {\r\n    /**\r\n     * New rendering behavior for rounded rectangles: circular arcs instead of quadratic bezier curves.\r\n     * In the next major release, we'll enable this by default.\r\n     */\r\n    static nextRoundedRectBehavior: boolean;\r\n    /**\r\n     * Temporary point to use for containsPoint.\r\n     * @private\r\n     */\r\n    static _TEMP_POINT: Point;\r\n    /**\r\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\r\n     * Can be shared between multiple Graphics objects.\r\n     */\r\n    shader: Shader;\r\n    /** Renderer plugin for batching */\r\n    pluginName: string;\r\n    /**\r\n     * Current path\r\n     * @readonly\r\n     */\r\n    currentPath: Polygon;\r\n    /** A collections of batches! These can be drawn by the renderer batch system. */\r\n    protected batches: Array<IGraphicsBatchElement>;\r\n    /** Update dirty for limiting calculating tints for batches. */\r\n    protected batchTint: number;\r\n    /** Update dirty for limiting calculating batches.*/\r\n    protected batchDirty: number;\r\n    /** Copy of the object vertex data. */\r\n    protected vertexData: Float32Array;\r\n    /** Current fill style. */\r\n    protected _fillStyle: FillStyle;\r\n    /** Current line style. */\r\n    protected _lineStyle: LineStyle;\r\n    /** Current shape transform matrix. */\r\n    protected _matrix: Matrix;\r\n    /** Current hole mode is enabled. */\r\n    protected _holeMode: boolean;\r\n    protected _transformID: number;\r\n    protected _tint: number;\r\n    /**\r\n     * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\r\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\r\n     */\r\n    private state;\r\n    private _geometry;\r\n    /**\r\n     * Includes vertex positions, face indices, normals, colors, UVs, and\r\n     * custom attributes within buffers, reducing the cost of passing all\r\n     * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\r\n     * @readonly\r\n     */\r\n    get geometry(): GraphicsGeometry;\r\n    /**\r\n     * @param geometry - Geometry to use, if omitted will create a new GraphicsGeometry instance.\r\n     */\r\n    constructor(geometry?: GraphicsGeometry);\r\n    /**\r\n     * Creates a new Graphics object with the same values as this one.\r\n     * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)\r\n     * @returns - A clone of the graphics object\r\n     */\r\n    clone(): Graphics;\r\n    /**\r\n     * The blend mode to be applied to the graphic shape. Apply a value of\r\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each\r\n     * primitive in the GraphicsGeometry list is rendered sequentially, modes\r\n     * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will\r\n     * be applied per-primitive.\r\n     * @default PIXI.BLEND_MODES.NORMAL\r\n     */\r\n    set blendMode(value: BLEND_MODES);\r\n    get blendMode(): BLEND_MODES;\r\n    /**\r\n     * The tint applied to each graphic shape. This is a hex value. A value of\r\n     * 0xFFFFFF will remove any tint effect.\r\n     * @default 0xFFFFFF\r\n     */\r\n    get tint(): number;\r\n    set tint(value: number);\r\n    /**\r\n     * The current fill style.\r\n     * @readonly\r\n     */\r\n    get fill(): FillStyle;\r\n    /**\r\n     * The current line style.\r\n     * @readonly\r\n     */\r\n    get line(): LineStyle;\r\n    /**\r\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\r\n     * method or the drawCircle() method.\r\n     * @param [width=0] - width of the line to draw, will update the objects stored style\r\n     * @param [color=0x0] - color of the line to draw, will update the objects stored style\r\n     * @param [alpha=1] - alpha of the line to draw, will update the objects stored style\r\n     * @param [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\r\n     *        WebGL only.\r\n     * @param [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\r\n     * @returns - This Graphics object. Good for chaining method calls\r\n     */\r\n    lineStyle(width: number, color?: number, alpha?: number, alignment?: number, native?: boolean): this;\r\n    /**\r\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\r\n     * method or the drawCircle() method.\r\n     * @param options - Line style options\r\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\r\n     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style\r\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\r\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\r\n     *        WebGL only.\r\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\r\n     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\r\n     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\r\n     * @param {number}[options.miterLimit=10] - miter limit ratio\r\n     * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\r\n     */\r\n    lineStyle(options?: ILineStyleOptions): this;\r\n    /**\r\n     * Like line style but support texture for line fill.\r\n     * @param [options] - Collection of options for setting line style.\r\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\r\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\r\n     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style.\r\n     *  Default 0xFFFFFF if texture present.\r\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\r\n     * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture\r\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\r\n     *        WebGL only.\r\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\r\n     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\r\n     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\r\n     * @param {number}[options.miterLimit=10] - miter limit ratio\r\n     * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\r\n     */\r\n    lineTextureStyle(options?: ILineStyleOptions): this;\r\n    /**\r\n     * Start a polygon object internally.\r\n     * @protected\r\n     */\r\n    protected startPoly(): void;\r\n    /**\r\n     * Finish the polygon object.\r\n     * @protected\r\n     */\r\n    finishPoly(): void;\r\n    /**\r\n     * Moves the current drawing position to x, y.\r\n     * @param x - the X coordinate to move to\r\n     * @param y - the Y coordinate to move to\r\n     * @returns - This Graphics object. Good for chaining method calls\r\n     */\r\n    moveTo(x: number, y: number): this;\r\n    /**\r\n     * Draws a line using the current line style from the current drawing position to (x, y);\r\n     * The current drawing position is then set to (x, y).\r\n     * @param x - the X coordinate to draw to\r\n     * @param y - the Y coordinate to draw to\r\n     * @returns - This Graphics object. Good for chaining method calls\r\n     */\r\n    lineTo(x: number, y: number): this;\r\n    /**\r\n     * Initialize the curve\r\n     * @param x\r\n     * @param y\r\n     */\r\n    protected _initCurve(x?: number, y?: number): void;\r\n    /**\r\n     * Calculate the points for a quadratic bezier curve and then draws it.\r\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\r\n     * @param cpX - Control point x\r\n     * @param cpY - Control point y\r\n     * @param toX - Destination point x\r\n     * @param toY - Destination point y\r\n     * @returns - This Graphics object. Good for chaining method calls\r\n     */\r\n    quadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): this;\r\n    /**\r\n     * Calculate the points for a bezier curve and then draws it.\r\n     * @param cpX - Control point x\r\n     * @param cpY - Control point y\r\n     * @param cpX2 - Second Control point x\r\n     * @param cpY2 - Second Control point y\r\n     * @param toX - Destination point x\r\n     * @param toY - Destination point y\r\n     * @returns This Graphics object. Good for chaining method calls\r\n     */\r\n    bezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): this;\r\n    /**\r\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\r\n     *\r\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\r\n     * @param x1 - The x-coordinate of the first tangent point of the arc\r\n     * @param y1 - The y-coordinate of the first tangent point of the arc\r\n     * @param x2 - The x-coordinate of the end of the arc\r\n     * @param y2 - The y-coordinate of the end of the arc\r\n     * @param radius - The radius of the arc\r\n     * @returns - This Graphics object. Good for chaining method calls\r\n     */\r\n    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\r\n    /**\r\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\r\n     * @param cx - The x-coordinate of the center of the circle\r\n     * @param cy - The y-coordinate of the center of the circle\r\n     * @param radius - The radius of the circle\r\n     * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\r\n     *  of the arc's circle)\r\n     * @param endAngle - The ending angle, in radians\r\n     * @param anticlockwise - Specifies whether the drawing should be\r\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\r\n     *  indicates counter-clockwise.\r\n     * @returns - This Graphics object. Good for chaining method calls\r\n     */\r\n    arc(cx: number, cy: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): this;\r\n    /**\r\n     * Specifies a simple one-color fill that subsequent calls to other Graphics methods\r\n     * (such as lineTo() or drawCircle()) use when drawing.\r\n     * @param color - the color of the fill\r\n     * @param alpha - the alpha of the fill\r\n     * @returns - This Graphics object. Good for chaining method calls\r\n     */\r\n    beginFill(color?: number, alpha?: number): this;\r\n    /**\r\n     * Begin the texture fill\r\n     * @param options - Object object.\r\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\r\n     * @param {number} [options.color=0xffffff] - Background to fill behind texture\r\n     * @param {number} [options.alpha=1] - Alpha of fill\r\n     * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\r\n     * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\r\n     */\r\n    beginTextureFill(options?: IFillStyleOptions): this;\r\n    /**\r\n     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\r\n     * @returns - This Graphics object. Good for chaining method calls\r\n     */\r\n    endFill(): this;\r\n    /**\r\n     * Draws a rectangle shape.\r\n     * @param x - The X coord of the top-left of the rectangle\r\n     * @param y - The Y coord of the top-left of the rectangle\r\n     * @param width - The width of the rectangle\r\n     * @param height - The height of the rectangle\r\n     * @returns - This Graphics object. Good for chaining method calls\r\n     */\r\n    drawRect(x: number, y: number, width: number, height: number): this;\r\n    /**\r\n     * Draw a rectangle shape with rounded/beveled corners.\r\n     * @param x - The X coord of the top-left of the rectangle\r\n     * @param y - The Y coord of the top-left of the rectangle\r\n     * @param width - The width of the rectangle\r\n     * @param height - The height of the rectangle\r\n     * @param radius - Radius of the rectangle corners\r\n     * @returns - This Graphics object. Good for chaining method calls\r\n     */\r\n    drawRoundedRect(x: number, y: number, width: number, height: number, radius: number): this;\r\n    /**\r\n     * Draws a circle.\r\n     * @param x - The X coordinate of the center of the circle\r\n     * @param y - The Y coordinate of the center of the circle\r\n     * @param radius - The radius of the circle\r\n     * @returns - This Graphics object. Good for chaining method calls\r\n     */\r\n    drawCircle(x: number, y: number, radius: number): this;\r\n    /**\r\n     * Draws an ellipse.\r\n     * @param x - The X coordinate of the center of the ellipse\r\n     * @param y - The Y coordinate of the center of the ellipse\r\n     * @param width - The half width of the ellipse\r\n     * @param height - The half height of the ellipse\r\n     * @returns - This Graphics object. Good for chaining method calls\r\n     */\r\n    drawEllipse(x: number, y: number, width: number, height: number): this;\r\n    drawPolygon(...path: Array<number> | Array<Point>): this;\r\n    drawPolygon(path: Array<number> | Array<Point> | Polygon): this;\r\n    /**\r\n     * Draw any shape.\r\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\r\n     * @returns - This Graphics object. Good for chaining method calls\r\n     */\r\n    drawShape(shape: IShape): this;\r\n    /**\r\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\r\n     * @returns - This Graphics object. Good for chaining method calls\r\n     */\r\n    clear(): this;\r\n    /**\r\n     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\r\n     * masked with gl.scissor.\r\n     * @returns - True if only 1 rect.\r\n     */\r\n    isFastRect(): boolean;\r\n    /**\r\n     * Renders the object using the WebGL renderer\r\n     * @param renderer - The renderer\r\n     */\r\n    protected _render(renderer: Renderer): void;\r\n    /** Populating batches for rendering. */\r\n    protected _populateBatches(): void;\r\n    /**\r\n     * Renders the batches using the BathedRenderer plugin\r\n     * @param renderer - The renderer\r\n     */\r\n    protected _renderBatched(renderer: Renderer): void;\r\n    /**\r\n     * Renders the graphics direct\r\n     * @param renderer - The renderer\r\n     */\r\n    protected _renderDirect(renderer: Renderer): void;\r\n    /**\r\n     * Renders specific DrawCall\r\n     * @param renderer\r\n     * @param drawCall\r\n     */\r\n    protected _renderDrawCallDirect(renderer: Renderer, drawCall: BatchDrawCall): void;\r\n    /**\r\n     * Resolves shader for direct rendering\r\n     * @param renderer - The renderer\r\n     */\r\n    protected _resolveDirectShader(renderer: Renderer): Shader;\r\n    /** Retrieves the bounds of the graphic shape as a rectangle object. */\r\n    protected _calculateBounds(): void;\r\n    /**\r\n     * Tests if a point is inside this graphics object\r\n     * @param point - the point to test\r\n     * @returns - the result of the test\r\n     */\r\n    containsPoint(point: IPointData): boolean;\r\n    /** Recalculate the tint by applying tint to batches using Graphics tint. */\r\n    protected calculateTints(): void;\r\n    /** If there's a transform update or a change to the shape of the geometry, recalculate the vertices. */\r\n    protected calculateVertices(): void;\r\n    /**\r\n     * Closes the current path.\r\n     * @returns - Returns itself.\r\n     */\r\n    closePath(): this;\r\n    /**\r\n     * Apply a matrix to the positional data.\r\n     * @param matrix - Matrix to use for transform current shape.\r\n     * @returns - Returns itself.\r\n     */\r\n    setMatrix(matrix: Matrix): this;\r\n    /**\r\n     * Begin adding holes to the last draw shape\r\n     * IMPORTANT: holes must be fully inside a shape to work\r\n     * Also weirdness ensues if holes overlap!\r\n     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\r\n     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\r\n     * @returns - Returns itself.\r\n     */\r\n    beginHole(): this;\r\n    /**\r\n     * End adding holes to the last draw shape.\r\n     * @returns - Returns itself.\r\n     */\r\n    endHole(): this;\r\n    /**\r\n     * Destroys the Graphics object.\r\n     * @param options - Options parameter. A boolean will act as if all\r\n     *  options have been set to that value\r\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\r\n     *  their destroy method called as well. 'options' will be passed on to those calls.\r\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\r\n     *  Should it destroy the texture of the child sprite\r\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\r\n     *  Should it destroy the base texture of the child sprite\r\n     */\r\n    destroy(options?: IDestroyOptions | boolean): void;\r\n}\r\n\r\n/**\r\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\r\n * the resolution is calculated based on the curve's length to ensure better visual quality.\r\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\r\n * @static\r\n * @constant\r\n * @memberof PIXI\r\n * @name GRAPHICS_CURVES\r\n * @type {object}\r\n * @property {boolean} [adaptive=true] - flag indicating if the resolution should be adaptive\r\n * @property {number} [maxLength=10] - maximal length of a single segment of the curve (if adaptive = false, ignored)\r\n * @property {number} [minSegments=8] - minimal number of segments in the curve (if adaptive = false, ignored)\r\n * @property {number} [maxSegments=2048] - maximal number of segments in the curve (if adaptive = false, ignored)\r\n */\r\nexport declare const GRAPHICS_CURVES: IGraphicsCurvesSettings;\r\n\r\n/**\r\n * A class to contain data useful for Graphics objects\r\n * @memberof PIXI\r\n */\r\nexport declare class GraphicsData {\r\n    /**\r\n     * The shape object to draw.\r\n     * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}\r\n     */\r\n    shape: IShape;\r\n    /** The style of the line. */\r\n    lineStyle: LineStyle;\r\n    /** The style of the fill. */\r\n    fillStyle: FillStyle;\r\n    /** The transform matrix. */\r\n    matrix: Matrix;\r\n    /** The type of the shape, see the Const.Shapes file for all the existing types, */\r\n    type: SHAPES;\r\n    /** The collection of points. */\r\n    points: number[];\r\n    /** The collection of holes. */\r\n    holes: Array<GraphicsData>;\r\n    /**\r\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\r\n     * @param fillStyle - the width of the line to draw\r\n     * @param lineStyle - the color of the line to draw\r\n     * @param matrix - Transform matrix\r\n     */\r\n    constructor(shape: IShape, fillStyle?: FillStyle, lineStyle?: LineStyle, matrix?: Matrix);\r\n    /**\r\n     * Creates a new GraphicsData object with the same values as this one.\r\n     * @returns - Cloned GraphicsData object\r\n     */\r\n    clone(): GraphicsData;\r\n    /** Destroys the Graphics data. */\r\n    destroy(): void;\r\n}\r\n\r\n/**\r\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\r\n * rectangles to the display, and to color and fill them.\r\n *\r\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\r\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\r\n * @memberof PIXI\r\n */\r\nexport declare class GraphicsGeometry extends BatchGeometry {\r\n    /**\r\n     * The maximum number of points to consider an object \"batchable\",\r\n     * able to be batched by the renderer's batch system.\r\n     \\\r\n     */\r\n    static BATCHABLE_SIZE: number;\r\n    /** Minimal distance between points that are considered different. Affects line tesselation. */\r\n    closePointEps: number;\r\n    /** Padding to add to the bounds. */\r\n    boundsPadding: number;\r\n    uvsFloat32: Float32Array;\r\n    indicesUint16: Uint16Array | Uint32Array;\r\n    batchable: boolean;\r\n    /** An array of points to draw, 2 numbers per point */\r\n    points: number[];\r\n    /** The collection of colors */\r\n    colors: number[];\r\n    /** The UVs collection */\r\n    uvs: number[];\r\n    /** The indices of the vertices */\r\n    indices: number[];\r\n    /** Reference to the texture IDs. */\r\n    textureIds: number[];\r\n    /**\r\n     * The collection of drawn shapes.\r\n     * @member {PIXI.GraphicsData[]}\r\n     */\r\n    graphicsData: Array<GraphicsData>;\r\n    /**\r\n     * List of current draw calls drived from the batches.\r\n     * @member {PIXI.BatchDrawCall[]}\r\n     */\r\n    drawCalls: Array<BatchDrawCall>;\r\n    /** Batches need to regenerated if the geometry is updated. */\r\n    batchDirty: number;\r\n    /**\r\n     * Intermediate abstract format sent to batch system.\r\n     * Can be converted to drawCalls or to batchable objects.\r\n     * @member {PIXI.graphicsUtils.BatchPart[]}\r\n     */\r\n    batches: Array<BatchPart>;\r\n    /** Used to detect if the graphics object has changed. */\r\n    protected dirty: number;\r\n    /** Used to check if the cache is dirty. */\r\n    protected cacheDirty: number;\r\n    /** Used to detect if we cleared the graphicsData. */\r\n    protected clearDirty: number;\r\n    /** Index of the last batched shape in the stack of calls. */\r\n    protected shapeIndex: number;\r\n    /** Cached bounds. */\r\n    protected _bounds: Bounds;\r\n    /** The bounds dirty flag. */\r\n    protected boundsDirty: number;\r\n    constructor();\r\n    /**\r\n     * Get the current bounds of the graphic geometry.\r\n     * @readonly\r\n     */\r\n    get bounds(): Bounds;\r\n    /** Call if you changed graphicsData manually. Empties all batch buffers. */\r\n    protected invalidate(): void;\r\n    /**\r\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\r\n     * @returns - This GraphicsGeometry object. Good for chaining method calls\r\n     */\r\n    clear(): GraphicsGeometry;\r\n    /**\r\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\r\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\r\n     * @param fillStyle - Defines style of the fill.\r\n     * @param lineStyle - Defines style of the lines.\r\n     * @param matrix - Transform applied to the points of the shape.\r\n     * @returns - Returns geometry for chaining.\r\n     */\r\n    drawShape(shape: IShape_2, fillStyle?: FillStyle, lineStyle?: LineStyle, matrix?: Matrix): GraphicsGeometry;\r\n    /**\r\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\r\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\r\n     * @param matrix - Transform applied to the points of the shape.\r\n     * @returns - Returns geometry for chaining.\r\n     */\r\n    drawHole(shape: IShape_2, matrix?: Matrix): GraphicsGeometry;\r\n    /** Destroys the GraphicsGeometry object. */\r\n    destroy(): void;\r\n    /**\r\n     * Check to see if a point is contained within this geometry.\r\n     * @param point - Point to check if it's contained.\r\n     * @returns {boolean} `true` if the point is contained within geometry.\r\n     */\r\n    containsPoint(point: IPointData): boolean;\r\n    /**\r\n     * Generates intermediate batch data. Either gets converted to drawCalls\r\n     * or used to convert to batch objects directly by the Graphics object.\r\n     * @param allow32Indices - Allow using 32-bit indices for preventing artifacts when more that 65535 vertices\r\n     */\r\n    updateBatches(allow32Indices?: boolean): void;\r\n    /**\r\n     * Affinity check\r\n     * @param styleA\r\n     * @param styleB\r\n     */\r\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean;\r\n    /** Test geometry for batching process. */\r\n    protected validateBatching(): boolean;\r\n    /** Offset the indices so that it works with the batcher. */\r\n    protected packBatches(): void;\r\n    /**\r\n     * Checks to see if this graphics geometry can be batched.\r\n     * Currently it needs to be small enough and not contain any native lines.\r\n     */\r\n    protected isBatchable(): boolean;\r\n    /** Converts intermediate batches data to drawCalls. */\r\n    protected buildDrawCalls(): void;\r\n    /** Packs attributes to single buffer. */\r\n    protected packAttributes(): void;\r\n    /**\r\n     * Process fill part of Graphics.\r\n     * @param data\r\n     */\r\n    protected processFill(data: GraphicsData): void;\r\n    /**\r\n     * Process line part of Graphics.\r\n     * @param data\r\n     */\r\n    protected processLine(data: GraphicsData): void;\r\n    /**\r\n     * Process the holes data.\r\n     * @param holes\r\n     */\r\n    protected processHoles(holes: Array<GraphicsData>): void;\r\n    /** Update the local bounds of the object. Expensive to use performance-wise. */\r\n    protected calculateBounds(): void;\r\n    /**\r\n     * Transform points using matrix.\r\n     * @param points - Points to transform\r\n     * @param matrix - Transform matrix\r\n     */\r\n    protected transformPoints(points: Array<number>, matrix: Matrix): void;\r\n    /**\r\n     * Add colors.\r\n     * @param colors - List of colors to add to\r\n     * @param color - Color to add\r\n     * @param alpha - Alpha to use\r\n     * @param size - Number of colors to add\r\n     * @param offset\r\n     */\r\n    protected addColors(colors: Array<number>, color: number, alpha: number, size: number, offset?: number): void;\r\n    /**\r\n     * Add texture id that the shader/fragment wants to use.\r\n     * @param textureIds\r\n     * @param id\r\n     * @param size\r\n     * @param offset\r\n     */\r\n    protected addTextureIds(textureIds: Array<number>, id: number, size: number, offset?: number): void;\r\n    /**\r\n     * Generates the UVs for a shape.\r\n     * @param verts - Vertices\r\n     * @param uvs - UVs\r\n     * @param texture - Reference to Texture\r\n     * @param start - Index buffer start index.\r\n     * @param size - The size/length for index buffer.\r\n     * @param matrix - Optional transform for all points.\r\n     */\r\n    protected addUvs(verts: Array<number>, uvs: Array<number>, texture: Texture, start: number, size: number, matrix?: Matrix): void;\r\n    /**\r\n     * Modify uvs array according to position of texture region\r\n     * Does not work with rotated or trimmed textures\r\n     * @param uvs - array\r\n     * @param texture - region\r\n     * @param start - starting index for uvs\r\n     * @param size - how many points to adjust\r\n     */\r\n    protected adjustUvs(uvs: Array<number>, texture: Texture, start: number, size: number): void;\r\n}\r\n\r\nexport declare const graphicsUtils: {\r\n    buildPoly: IShapeBuildCommand;\r\n    buildCircle: IShapeBuildCommand;\r\n    buildRectangle: IShapeBuildCommand;\r\n    buildRoundedRectangle: IShapeBuildCommand;\r\n    buildLine: typeof buildLine;\r\n    ArcUtils: typeof ArcUtils;\r\n    BezierUtils: typeof BezierUtils;\r\n    QuadraticUtils: typeof QuadraticUtils;\r\n    BatchPart: typeof BatchPart;\r\n    FILL_COMMANDS: Record<SHAPES, IShapeBuildCommand>;\r\n    BATCH_POOL: BatchPart[];\r\n    DRAW_CALL_POOL: BatchDrawCall_2[];\r\n};\r\n\r\ndeclare interface IArcLikeShape {\r\n    cx: number;\r\n    cy: number;\r\n    radius: number;\r\n    startAngle: number;\r\n    endAngle: number;\r\n    anticlockwise: boolean;\r\n}\r\n\r\nexport declare interface IFillStyleOptions {\r\n    color?: number;\r\n    alpha?: number;\r\n    texture?: Texture;\r\n    matrix?: Matrix;\r\n}\r\n\r\n/** Batch element computed from Graphics geometry */\r\nexport declare interface IGraphicsBatchElement {\r\n    vertexData: Float32Array;\r\n    blendMode: BLEND_MODES;\r\n    indices: Uint16Array | Uint32Array;\r\n    uvs: Float32Array;\r\n    alpha: number;\r\n    worldAlpha: number;\r\n    _batchRGB: number[];\r\n    _tintRGB: number;\r\n    _texture: Texture;\r\n}\r\n\r\nexport declare interface IGraphicsCurvesSettings {\r\n    adaptive: boolean;\r\n    maxLength: number;\r\n    minSegments: number;\r\n    maxSegments: number;\r\n    epsilon: number;\r\n    _segmentsCount(length: number, defaultSegments?: number): number;\r\n}\r\n\r\nexport declare interface ILineStyleOptions extends IFillStyleOptions {\r\n    width?: number;\r\n    alignment?: number;\r\n    native?: boolean;\r\n    cap?: LINE_CAP;\r\n    join?: LINE_JOIN;\r\n    miterLimit?: number;\r\n}\r\n\r\ndeclare type IShape_2 = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\r\n\r\ndeclare interface IShapeBuildCommand {\r\n    build(graphicsData: GraphicsData): void;\r\n    triangulate(graphicsData: GraphicsData, target: GraphicsGeometry): void;\r\n}\r\n\r\n/**\r\n * Support line caps in `PIXI.LineStyle` for graphics.\r\n * @see PIXI.Graphics#lineStyle\r\n * @name LINE_CAP\r\n * @memberof PIXI\r\n * @static\r\n * @enum {string}\r\n * @property {string} BUTT - 'butt': don't add any cap at line ends (leaves orthogonal edges)\r\n * @property {string} ROUND - 'round': add semicircle at ends\r\n * @property {string} SQUARE - 'square': add square at end (like `BUTT` except more length at end)\r\n */\r\nexport declare enum LINE_CAP {\r\n    BUTT = \"butt\",\r\n    ROUND = \"round\",\r\n    SQUARE = \"square\"\r\n}\r\n\r\n/**\r\n * Supported line joints in `PIXI.LineStyle` for graphics.\r\n * @see PIXI.Graphics#lineStyle\r\n * @see https://graphicdesign.stackexchange.com/questions/59018/what-is-a-bevel-join-of-two-lines-exactly-illustrator\r\n * @name LINE_JOIN\r\n * @memberof PIXI\r\n * @static\r\n * @enum {string}\r\n * @property {string} MITER - 'miter': make a sharp corner where outer part of lines meet\r\n * @property {string} BEVEL - 'bevel': add a square butt at each end of line segment and fill the triangle at turn\r\n * @property {string} ROUND - 'round': add an arc at the joint\r\n */\r\nexport declare enum LINE_JOIN {\r\n    MITER = \"miter\",\r\n    BEVEL = \"bevel\",\r\n    ROUND = \"round\"\r\n}\r\n\r\n/**\r\n * Represents the line style for Graphics.\r\n * @memberof PIXI\r\n */\r\nexport declare class LineStyle extends FillStyle {\r\n    /** The width (thickness) of any lines drawn. */\r\n    width: number;\r\n    /** The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner). WebGL only. */\r\n    alignment: number;\r\n    /** If true the lines will be draw using LINES instead of TRIANGLE_STRIP. */\r\n    native: boolean;\r\n    /**\r\n     * Line cap style.\r\n     * @member {PIXI.LINE_CAP}\r\n     * @default PIXI.LINE_CAP.BUTT\r\n     */\r\n    cap: LINE_CAP;\r\n    /**\r\n     * Line join style.\r\n     * @member {PIXI.LINE_JOIN}\r\n     * @default PIXI.LINE_JOIN.MITER\r\n     */\r\n    join: LINE_JOIN;\r\n    /** Miter limit. */\r\n    miterLimit: number;\r\n    /** Clones the object. */\r\n    clone(): LineStyle;\r\n    /** Reset the line style to default. */\r\n    reset(): void;\r\n}\r\n\r\n/**\r\n * Utilities for quadratic curves.\r\n * @private\r\n */\r\ndeclare class QuadraticUtils {\r\n    /**\r\n     * Calculate length of quadratic curve\r\n     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\r\n     * for the detailed explanation of math behind this.\r\n     * @private\r\n     * @param fromX - x-coordinate of curve start point\r\n     * @param fromY - y-coordinate of curve start point\r\n     * @param cpX - x-coordinate of curve control point\r\n     * @param cpY - y-coordinate of curve control point\r\n     * @param toX - x-coordinate of curve end point\r\n     * @param toY - y-coordinate of curve end point\r\n     * @returns - Length of quadratic curve\r\n     */\r\n    static curveLength(fromX: number, fromY: number, cpX: number, cpY: number, toX: number, toY: number): number;\r\n    /**\r\n     * Calculate the points for a quadratic bezier curve and then draws it.\r\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\r\n     * @private\r\n     * @param cpX - Control point x\r\n     * @param cpY - Control point y\r\n     * @param toX - Destination point x\r\n     * @param toY - Destination point y\r\n     * @param points - Points to add segments to.\r\n     */\r\n    static curveTo(cpX: number, cpY: number, toX: number, toY: number, points: Array<number>): void;\r\n}\r\n\r\nexport { }\r\n"
    ]
  