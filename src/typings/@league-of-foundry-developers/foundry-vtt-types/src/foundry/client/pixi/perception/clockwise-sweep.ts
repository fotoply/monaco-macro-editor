
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\client\\pixi\\perception\\clockwise-sweep.d.ts",
      "import type { ConfiguredObjectClassForName } from '../../../../types/helperTypes';\n\ndeclare global {\n  type VertexMap = Map<number, PolygonVertex>;\n\n  type EdgeSet = Set<PolygonEdge>;\n\n  interface ClockwiseSweepPolygonConfig extends PointSourcePolygonConfig {\n    /** @defaultValue `canvas.dimensions.maxR` */\n    radius?: number;\n\n    /** @defaultValue `360` */\n    angle?: number;\n\n    /** @defaultValue `0` */\n    rotation?: number;\n\n    /**\n     * The desired density of padding rays, a number per PI\n     * @defaultValue `12`\n     */\n    density?: number;\n\n    /**\n     * The minimum angle of emission\n     * @defaultValue `config.hasLimitedAngle ? Math.normalizeRadians(Math.toRadians(config.rotation + 90 - (config.angle / 2))) : -Math.PI`\n     */\n    aMin?: number;\n\n    /**\n     * The maximum angle of emission\n     * @defaultValue `config.hasLimitedAngle ? config.aMin + Math.toRadians(config.angle) : Math.PI`\n     */\n    aMax?: number;\n\n    /**\n     * The minimum ray of emission\n     * @defaultValue `Ray.fromAngle(origin.x, origin.y, config.aMin, config.radius)`\n     */\n    rMin?: PolygonRay;\n\n    /**\n     * The maximum ray of emission\n     * @defaultValue `config.hasLimitedAngle && Ray.fromAngle(origin.x, origin.y, config.aMax, config.radius)`\n     */\n    rMax?: PolygonRay;\n\n    /**\n     * Does this polygon have a limited radius?\n     * @defaultValue `config.radius > 0`\n     */\n    hasLimitedRadius?: boolean;\n\n    /**\n     * Does this polygon have a limited angle?\n     * @defaultValue `config.angle !== 0`\n     */\n    hasLimitedAngle?: boolean;\n\n    /**\n     * The squared radius of the polygon, for faster computation later\n     * @defaultValue `Math.pow(config.radius, 2)`\n     */\n    radius2?: number;\n\n    /**\n     * A small epsilon used for avoiding floating point precision issues\n     * @defaultValue `0.5 / config.radius`\n     */\n    radiusE?: number;\n  }\n\n  interface PolygonRay extends Ray {\n    result: CollisionResult;\n  }\n\n  /**\n   * A PointSourcePolygon implementation that uses CCW (counter-clockwise) geometry orientation.\n   * Sweep around the origin, accumulating collision points based on the set of active walls.\n   * This algorithm was created with valuable contributions from https://github.com/caewok\n   */\n  class ClockwiseSweepPolygon extends PointSourcePolygon {\n    /**\n     * The configuration of this polygon.\n     */\n    config:\n      | ClockwiseSweepPolygonConfig\n      | ClockwiseSweepPolygon.InitializedConfig\n      | ClockwiseSweepPolygon.LimitedAngleConfig;\n\n    /**\n     * A mapping of vertices which define potential collision points\n     */\n    vertices: VertexMap;\n\n    /**\n     * The set of edges which define potential boundaries of the polygon\n     */\n    edges: EdgeSet;\n\n    /**\n     * A collection of rays which are fired at vertices\n     */\n    rays: PolygonRay[];\n\n    static benchmark(\n      iterations: number,\n      ...args: Parameters<typeof ClockwiseSweepPolygon['create']>\n    ): ReturnType<typeof foundry.utils.benchmark>;\n\n    static create(\n      origin: Point,\n      config: Parameters<ClockwiseSweepPolygon['initialize']>[1]\n    ): ReturnType<ClockwiseSweepPolygon['compute']>;\n\n    /**\n     * @param origin - The provided polygon origin\n     * @param config - The provided configuration object\n     */\n    override initialize(origin: Point, config: ClockwiseSweepPolygon.InitConfig): void;\n\n    protected override _compute(): void;\n\n    /**\n     * Round vertices of a ray segment\n     * @param ray - The provided ray\n     * @returns The ray with rounded vertices\n     * @internal\n     */\n    protected _roundRayVertices(ray: PolygonRay): PolygonRay;\n\n    /**\n     * Translate walls and other obstacles into edges which limit visibility\n     * @internal\n     */\n    protected _identifyEdges(): void;\n\n    /**\n     * Get the super-set of walls which could potentially apply to this polygon.\n     * @internal\n     */\n    protected _getWalls(): ConfiguredObjectClassForName<'Wall'>[];\n\n    /**\n     * Restrict the set of candidate edges to those which appear within the limited angle of emission.\n     * @internal\n     */\n    protected _restrictEdgesByAngle(): void;\n\n    /**\n     * Process the candidate edges to further constrain them using a circular radius of effect.\n     * @internal\n     */\n    protected _constrainEdgesByRadius(): void;\n\n    /**\n     * Consolidate all vertices from identified edges and register them as part of the vertex mapping.\n     * @internal\n     */\n    protected _identifyVertices(): void;\n\n    /**\n     * Add additional vertices for intersections between edges.\n     * @param wallEdgeMap - A mapping of wall IDs to PolygonEdge instances\n     * @internal\n     */\n    protected _identifyIntersections(wallEdgeMap: Map<string, PolygonEdge>): void;\n\n    /**\n     * Execute the sweep over wall vertices\n     * @internal\n     */\n    protected _executeSweep(): void;\n\n    /**\n     * Determine the initial set of active edges as those which intersect with the initial ray\n     * @returns A set of initially active edges\n     * @internal\n     */\n    protected _initializeActiveEdges(): EdgeSet;\n\n    /**\n     * Sort vertices clockwise from the initial ray (due west).\n     * @returns The array of sorted vertices\n     * @internal\n     */\n    protected _sortVertices(): PolygonVertex[];\n\n    /**\n     * Test whether a target vertex is behind some closer active edge\n     * @param ray         - The ray being evaluated\n     * @param vertex      - The target vertex\n     * @param activeEdges - The set of active edges\n     * @returns Is the target vertex behind some closer edge?\n     * @internal\n     */\n    protected _isVertexBehindActiveEdges(\n      ray: PolygonRay,\n      vertex: PolygonVertex,\n      activeEdges: EdgeSet\n    ): { isBehind: boolean; wasLimited: boolean };\n\n    /**\n     * Determine the final result of a candidate ray.\n     * @param ray         - The candidate ray being tested\n     * @param vertex      - The target vertex\n     * @param result      - The result being prepared\n     * @param activeEdges - The set of active edges\n     * @internal\n     */\n    protected _determineRayResult(\n      ray: PolygonRay,\n      vertex: PolygonVertex,\n      result: CollisionResult,\n      activeEdges: EdgeSet\n    ): void;\n\n    /**\n     * Jump to a new closest active edge.\n     * In this case, our target vertex will be the primary collision.\n     * We may have a secondary collision if other active edges exist or if the vertex is prior to the ray endpoint.\n     * @internal\n     *\n     * @param ray             - The ray being emitted\n     * @param result          - The pending collision result\n     * @param activeEdges     - The set of currently active edges\n     * @param isBinding       - Is the target vertex a binding collision point?\n     * @param secondaryBefore - Whether to add secondary collision points before (\"unshift\") or after (\"push\")\n     *                          (default: `true`)\n     */\n    protected _beginNewEdge(\n      ray: PolygonRay,\n      result: CollisionResult,\n      activeEdges: EdgeSet,\n      isBinding: boolean,\n      secondaryBefore?: boolean\n    ): void;\n\n    /**\n     * If the target vertex is connected to a currently active edge, we are terminating that edge.\n     * We know the target vertex is not behind another edge, so the target is our initial collision.\n     * There may be a second collision afterwards if no connected walls continue clockwise.\n     * @internal\n     *\n     * @param ray         - The ray being emitted\n     * @param result      - The pending collision result\n     * @param activeEdges - The set of currently active edges\n     * @param isBinding   - Is the target vertex a binding collision point?\n     */\n    protected _completeCurrentEdge(\n      ray: PolygonRay,\n      result: CollisionResult,\n      activeEdges: EdgeSet,\n      isBinding: boolean\n    ): void;\n\n    /**\n     * Augment a CollisionResult with an additional secondary collision.\n     * Require secondary collisions to be a greater distance than the target vertex.\n     * @param ray    - The ray being evaluated\n     * @param result - The collision result\n     * @param edges  - The subset of active edges which are candidates for collision\n     * @internal\n     */\n    protected _getSecondaryCollisions(ray: PolygonRay, result: CollisionResult, edges: EdgeSet): PolygonVertex[];\n\n    /**\n     * Identify collision points for a required terminal ray.\n     * @internal\n     *\n     * @param ray         - The ray being emitted\n     * @param result      - The pending collision result\n     * @param activeEdges - The set of currently active edges\n     */\n    protected _findRequiredCollision(ray: PolygonRay, result: CollisionResult, activeEdges: EdgeSet): void;\n\n    /**\n     * Identify the collision points between an emitted Ray and a set of active edges.\n     * @param ray             - The candidate ray to test\n     * @param activeEdges     - The set of active edges\n     * @returns A sorted array of collision points\n     * @internal\n     */\n    protected _getRayCollisions(\n      ray: PolygonRay,\n      activeEdges: EdgeSet,\n      {\n        minimumDistance\n      }?: {\n        /**\n         * Require collisions to exceed some minimum distance\n         * @defaultValue `0`\n         */\n        minimumDistance?: number;\n      }\n    ): PolygonVertex[];\n\n    /**\n     * Update the set of active edges given the result of an emitted ray.\n     * @param result      - The collision result\n     * @param activeEdges - The set of currently active edges\n     * @internal\n     */\n    protected _updateActiveEdges(result: CollisionResult, activeEdges: EdgeSet): void;\n\n    /**\n     * Construct the polygon from ray collision points\n     * @internal\n     */\n    protected _constructPolygonPoints(): void;\n\n    /**\n     * Add additional points to limited-radius polygons to approximate the curvature of a circle\n     * @param r0 - The prior ray that collided with some vertex\n     * @param r1 - The next ray that collides with some vertex\n     * @internal\n     */\n    protected _getPaddingPoints(r0: PolygonRay, r1: PolygonRay): Point[];\n\n    /**\n     * Test whether a wall should be included in the computed polygon for a given origin and type\n     * @param wall   - The Wall being considered\n     * @param origin - The origin point for the ray or polygon\n     * @param type   - The type of perception or movement restriction being imposed\n     * @returns Should the wall be included?\n     *\n     */\n    static testWallInclusion(\n      wall: ConfiguredObjectClassForName<'Wall'>,\n      origin: Point,\n      type: foundry.CONST.WALL_RESTRICTION_TYPES\n    ): boolean;\n\n    /**\n     * Test whether a vertex lies between two boundary rays\n     * @param vertex - The target vertex\n     * @param rMin   - The counter-clockwise bounding ray\n     * @param rMax   - The clockwise bounding ray\n     * @param angle  - The angle being tested, in degrees\n     * @returns Is the vertex between the two rays?\n     */\n    static pointBetweenRays(vertex: PolygonVertex, rMin: PolygonRay, rMax: PolygonRay, angle: number): boolean;\n\n    override visualize(): void;\n\n    /**\n     * Check whether a given ray intersects with walls.\n     * @param ray     - The Ray being tested\n     * @param options - Options which customize how collision is tested\n     * @returns Whether any collision occurred if mode is \"any\"\n     *          An array of collisions, if mode is \"all\"\n     *          The closest collision, if mode is \"closest\"\n     */\n    static getRayCollisions<Mode extends 'any' | 'closest' | 'all'>(\n      ray: PolygonRay,\n      options?: {\n        /**\n         * Which collision type to check, a value in CONST.WALL_RESTRICTION_TYPES\n         * @defaultValue `\"move\"`\n         */\n        type?: foundry.CONST.WALL_RESTRICTION_TYPES;\n\n        /**\n         * Which type of collisions are returned: any, closest, all\n         * @defaultValue `\"all\"`\n         */\n        mode?: Mode;\n\n        /**\n         * Visualize some debugging data to help understand the collision test\n         * @defaultValue `false`\n         */\n        debug?: boolean;\n      }\n    ): Mode extends 'any' ? boolean : Mode extends 'closest' ? PolygonVertex : PolygonVertex[];\n\n    /**\n     * Visualize the polygon, displaying its computed area, rays, and collision points\n     * @internal\n     */\n    protected static _visualizeCollision(ray: PolygonRay, edges: EdgeSet, collisions: PolygonVertex[]): void;\n  }\n\n  namespace ClockwiseSweepPolygon {\n    type InitConfig = Partial<Pick<ClockwiseSweepPolygonConfig, 'radius' | 'angle' | 'rotation' | 'density'>>;\n\n    interface InitializedConfig extends ClockwiseSweepPolygonConfig {\n      hasLimitedRadius: boolean;\n      radius: number;\n      radius2: number;\n      radiusE: number;\n      aMin: number;\n      aMax: number;\n      angle: number;\n      rotation: number;\n      hasLimitedAngle: boolean;\n      density: number;\n      rMin: PolygonRay;\n    }\n\n    interface LimitedAngleConfig extends InitializedConfig {\n      hasLimitedAngle: true;\n      rMax: PolygonRay;\n    }\n  }\n}\n"
    ]
  