
    export default [
      "@pixi\\math\\index.d.ts",
      "/// <reference path=\"./global.d.ts\" />\n\n/**\r\n * The Circle object is used to help draw graphics and can also be used to specify a hit area for displayObjects.\r\n * @memberof PIXI\r\n */\r\nexport declare class Circle {\r\n    /** @default 0 */\r\n    x: number;\r\n    /** @default 0 */\r\n    y: number;\r\n    /** @default 0 */\r\n    radius: number;\r\n    /**\r\n     * The type of the object, mainly used to avoid `instanceof` checks\r\n     * @default PIXI.SHAPES.CIRC\r\n     * @see PIXI.SHAPES\r\n     */\r\n    readonly type: SHAPES.CIRC;\r\n    /**\r\n     * @param x - The X coordinate of the center of this circle\r\n     * @param y - The Y coordinate of the center of this circle\r\n     * @param radius - The radius of the circle\r\n     */\r\n    constructor(x?: number, y?: number, radius?: number);\r\n    /**\r\n     * Creates a clone of this Circle instance\r\n     * @returns A copy of the Circle\r\n     */\r\n    clone(): Circle;\r\n    /**\r\n     * Checks whether the x and y coordinates given are contained within this circle\r\n     * @param x - The X coordinate of the point to test\r\n     * @param y - The Y coordinate of the point to test\r\n     * @returns Whether the x/y coordinates are within this Circle\r\n     */\r\n    contains(x: number, y: number): boolean;\r\n    /**\r\n     * Returns the framing rectangle of the circle as a Rectangle object\r\n     * @returns The framing rectangle\r\n     */\r\n    getBounds(): Rectangle;\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * Conversion factor for converting degrees to radians.\r\n * @static\r\n * @member {number}\r\n * @memberof PIXI\r\n */\r\nexport declare const DEG_TO_RAD: number;\r\n\r\n/**\r\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for displayObjects.\r\n * @memberof PIXI\r\n */\r\nexport declare class Ellipse {\r\n    /** @default 0 */\r\n    x: number;\r\n    /** @default 0 */\r\n    y: number;\r\n    /** @default 0 */\r\n    width: number;\r\n    /** @default 0 */\r\n    height: number;\r\n    /**\r\n     * The type of the object, mainly used to avoid `instanceof` checks\r\n     * @default PIXI.SHAPES.ELIP\r\n     * @see PIXI.SHAPES\r\n     */\r\n    readonly type: SHAPES.ELIP;\r\n    /**\r\n     * @param x - The X coordinate of the center of this ellipse\r\n     * @param y - The Y coordinate of the center of this ellipse\r\n     * @param halfWidth - The half width of this ellipse\r\n     * @param halfHeight - The half height of this ellipse\r\n     */\r\n    constructor(x?: number, y?: number, halfWidth?: number, halfHeight?: number);\r\n    /**\r\n     * Creates a clone of this Ellipse instance\r\n     * @returns {PIXI.Ellipse} A copy of the ellipse\r\n     */\r\n    clone(): Ellipse;\r\n    /**\r\n     * Checks whether the x and y coordinates given are contained within this ellipse\r\n     * @param x - The X coordinate of the point to test\r\n     * @param y - The Y coordinate of the point to test\r\n     * @returns Whether the x/y coords are within this ellipse\r\n     */\r\n    contains(x: number, y: number): boolean;\r\n    /**\r\n     * Returns the framing rectangle of the ellipse as a Rectangle object\r\n     * @returns The framing rectangle\r\n     */\r\n    getBounds(): Rectangle;\r\n    toString(): string;\r\n}\r\n\r\ndeclare type GD8Symmetry = number;\r\n\r\n/**\r\n * Implements the dihedral group D8, which is similar to\r\n * [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html};\r\n * D8 is the same but with diagonals, and it is used for texture\r\n * rotations.\r\n *\r\n * The directions the U- and V- axes after rotation\r\n * of an angle of `a: GD8Constant` are the vectors `(uX(a), uY(a))`\r\n * and `(vX(a), vY(a))`. These aren't necessarily unit vectors.\r\n *\r\n * **Origin:**<br>\r\n *  This is the small part of gameofbombs.com portal system. It works.\r\n * @see PIXI.groupD8.E\r\n * @see PIXI.groupD8.SE\r\n * @see PIXI.groupD8.S\r\n * @see PIXI.groupD8.SW\r\n * @see PIXI.groupD8.W\r\n * @see PIXI.groupD8.NW\r\n * @see PIXI.groupD8.N\r\n * @see PIXI.groupD8.NE\r\n * @author Ivan @ivanpopelyshev\r\n * @namespace PIXI.groupD8\r\n * @memberof PIXI\r\n */\r\nexport declare const groupD8: {\r\n    /**\r\n     * | Rotation | Direction |\r\n     * |----------|-----------|\r\n     * | 0°       | East      |\r\n     * @memberof PIXI.groupD8\r\n     * @constant {PIXI.GD8Symmetry}\r\n     */\r\n    E: number;\r\n    /**\r\n     * | Rotation | Direction |\r\n     * |----------|-----------|\r\n     * | 45°↻     | Southeast |\r\n     * @memberof PIXI.groupD8\r\n     * @constant {PIXI.GD8Symmetry}\r\n     */\r\n    SE: number;\r\n    /**\r\n     * | Rotation | Direction |\r\n     * |----------|-----------|\r\n     * | 90°↻     | South     |\r\n     * @memberof PIXI.groupD8\r\n     * @constant {PIXI.GD8Symmetry}\r\n     */\r\n    S: number;\r\n    /**\r\n     * | Rotation | Direction |\r\n     * |----------|-----------|\r\n     * | 135°↻    | Southwest |\r\n     * @memberof PIXI.groupD8\r\n     * @constant {PIXI.GD8Symmetry}\r\n     */\r\n    SW: number;\r\n    /**\r\n     * | Rotation | Direction |\r\n     * |----------|-----------|\r\n     * | 180°     | West      |\r\n     * @memberof PIXI.groupD8\r\n     * @constant {PIXI.GD8Symmetry}\r\n     */\r\n    W: number;\r\n    /**\r\n     * | Rotation    | Direction    |\r\n     * |-------------|--------------|\r\n     * | -135°/225°↻ | Northwest    |\r\n     * @memberof PIXI.groupD8\r\n     * @constant {PIXI.GD8Symmetry}\r\n     */\r\n    NW: number;\r\n    /**\r\n     * | Rotation    | Direction    |\r\n     * |-------------|--------------|\r\n     * | -90°/270°↻  | North        |\r\n     * @memberof PIXI.groupD8\r\n     * @constant {PIXI.GD8Symmetry}\r\n     */\r\n    N: number;\r\n    /**\r\n     * | Rotation    | Direction    |\r\n     * |-------------|--------------|\r\n     * | -45°/315°↻  | Northeast    |\r\n     * @memberof PIXI.groupD8\r\n     * @constant {PIXI.GD8Symmetry}\r\n     */\r\n    NE: number;\r\n    /**\r\n     * Reflection about Y-axis.\r\n     * @memberof PIXI.groupD8\r\n     * @constant {PIXI.GD8Symmetry}\r\n     */\r\n    MIRROR_VERTICAL: number;\r\n    /**\r\n     * Reflection about the main diagonal.\r\n     * @memberof PIXI.groupD8\r\n     * @constant {PIXI.GD8Symmetry}\r\n     */\r\n    MAIN_DIAGONAL: number;\r\n    /**\r\n     * Reflection about X-axis.\r\n     * @memberof PIXI.groupD8\r\n     * @constant {PIXI.GD8Symmetry}\r\n     */\r\n    MIRROR_HORIZONTAL: number;\r\n    /**\r\n     * Reflection about reverse diagonal.\r\n     * @memberof PIXI.groupD8\r\n     * @constant {PIXI.GD8Symmetry}\r\n     */\r\n    REVERSE_DIAGONAL: number;\r\n    /**\r\n     * @memberof PIXI.groupD8\r\n     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\r\n     * @returns {PIXI.GD8Symmetry} The X-component of the U-axis\r\n     *    after rotating the axes.\r\n     */\r\n    uX: (ind: GD8Symmetry) => GD8Symmetry;\r\n    /**\r\n     * @memberof PIXI.groupD8\r\n     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\r\n     * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis\r\n     *    after rotating the axes.\r\n     */\r\n    uY: (ind: GD8Symmetry) => GD8Symmetry;\r\n    /**\r\n     * @memberof PIXI.groupD8\r\n     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\r\n     * @returns {PIXI.GD8Symmetry} The X-component of the V-axis\r\n     *    after rotating the axes.\r\n     */\r\n    vX: (ind: GD8Symmetry) => GD8Symmetry;\r\n    /**\r\n     * @memberof PIXI.groupD8\r\n     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\r\n     * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis\r\n     *    after rotating the axes.\r\n     */\r\n    vY: (ind: GD8Symmetry) => GD8Symmetry;\r\n    /**\r\n     * @memberof PIXI.groupD8\r\n     * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite\r\n     *   is needed. Only rotations have opposite symmetries while\r\n     *   reflections don't.\r\n     * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`\r\n     */\r\n    inv: (rotation: GD8Symmetry) => GD8Symmetry;\r\n    /**\r\n     * Composes the two D8 operations.\r\n     *\r\n     * Taking `^` as reflection:\r\n     *\r\n     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\r\n     * |-------|-----|-----|-----|-----|------|-------|-------|-------|\r\n     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\r\n     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\r\n     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\r\n     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\r\n     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\r\n     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\r\n     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\r\n     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\r\n     *\r\n     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\r\n     * @memberof PIXI.groupD8\r\n     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which\r\n     *   is the row in the above cayley table.\r\n     * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which\r\n     *   is the column in the above cayley table.\r\n     * @returns {PIXI.GD8Symmetry} Composed operation\r\n     */\r\n    add: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry) => GD8Symmetry;\r\n    /**\r\n     * Reverse of `add`.\r\n     * @memberof PIXI.groupD8\r\n     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation\r\n     * @param {PIXI.GD8Symmetry} rotationFirst - First operation\r\n     * @returns {PIXI.GD8Symmetry} Result\r\n     */\r\n    sub: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry) => GD8Symmetry;\r\n    /**\r\n     * Adds 180 degrees to rotation, which is a commutative\r\n     * operation.\r\n     * @memberof PIXI.groupD8\r\n     * @param {number} rotation - The number to rotate.\r\n     * @returns {number} Rotated number\r\n     */\r\n    rotate180: (rotation: number) => number;\r\n    /**\r\n     * Checks if the rotation angle is vertical, i.e. south\r\n     * or north. It doesn't work for reflections.\r\n     * @memberof PIXI.groupD8\r\n     * @param {PIXI.GD8Symmetry} rotation - The number to check.\r\n     * @returns {boolean} Whether or not the direction is vertical\r\n     */\r\n    isVertical: (rotation: GD8Symmetry) => boolean;\r\n    /**\r\n     * Approximates the vector `V(dx,dy)` into one of the\r\n     * eight directions provided by `groupD8`.\r\n     * @memberof PIXI.groupD8\r\n     * @param {number} dx - X-component of the vector\r\n     * @param {number} dy - Y-component of the vector\r\n     * @returns {PIXI.GD8Symmetry} Approximation of the vector into\r\n     *  one of the eight symmetries.\r\n     */\r\n    byDirection: (dx: number, dy: number) => GD8Symmetry;\r\n    /**\r\n     * Helps sprite to compensate texture packer rotation.\r\n     * @memberof PIXI.groupD8\r\n     * @param {PIXI.Matrix} matrix - sprite world matrix\r\n     * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.\r\n     * @param {number} tx - sprite anchoring\r\n     * @param {number} ty - sprite anchoring\r\n     */\r\n    matrixAppendRotationInv: (matrix: Matrix, rotation: GD8Symmetry, tx?: number, ty?: number) => void;\r\n};\r\n\r\nexport declare interface IPoint extends IPointData {\r\n    copyFrom(p: IPointData): this;\r\n    copyTo<T extends IPoint>(p: T): T;\r\n    equals(p: IPointData): boolean;\r\n    set(x?: number, y?: number): void;\r\n}\r\n\r\nexport declare interface IPointData extends GlobalMixins.IPointData {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport declare type IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\r\n\r\nexport declare interface ISize {\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\n/**\r\n * The PixiJS Matrix as a class makes it a lot faster.\r\n *\r\n * Here is a representation of it:\r\n * ```js\r\n * | a | c | tx|\r\n * | b | d | ty|\r\n * | 0 | 0 | 1 |\r\n * ```\r\n * @memberof PIXI\r\n */\r\nexport declare class Matrix {\r\n    /** @default 1 */\r\n    a: number;\r\n    /** @default 0 */\r\n    b: number;\r\n    /** @default 0 */\r\n    c: number;\r\n    /** @default 1 */\r\n    d: number;\r\n    /** @default 0 */\r\n    tx: number;\r\n    /** @default 0 */\r\n    ty: number;\r\n    array: Float32Array | null;\r\n    /**\r\n     * @param a - x scale\r\n     * @param b - y skew\r\n     * @param c - x skew\r\n     * @param d - y scale\r\n     * @param tx - x translation\r\n     * @param ty - y translation\r\n     */\r\n    constructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number);\r\n    /**\r\n     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\r\n     *\r\n     * a = array[0]\r\n     * b = array[1]\r\n     * c = array[3]\r\n     * d = array[4]\r\n     * tx = array[2]\r\n     * ty = array[5]\r\n     * @param array - The array that the matrix will be populated from.\r\n     */\r\n    fromArray(array: number[]): void;\r\n    /**\r\n     * Sets the matrix properties.\r\n     * @param a - Matrix component\r\n     * @param b - Matrix component\r\n     * @param c - Matrix component\r\n     * @param d - Matrix component\r\n     * @param tx - Matrix component\r\n     * @param ty - Matrix component\r\n     * @returns This matrix. Good for chaining method calls.\r\n     */\r\n    set(a: number, b: number, c: number, d: number, tx: number, ty: number): this;\r\n    /**\r\n     * Creates an array from the current Matrix object.\r\n     * @param transpose - Whether we need to transpose the matrix or not\r\n     * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\r\n     * @returns The newly created array which contains the matrix\r\n     */\r\n    toArray(transpose: boolean, out?: Float32Array): Float32Array;\r\n    /**\r\n     * Get a new position with the current transformation applied.\r\n     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\r\n     * @param pos - The origin\r\n     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\r\n     * @returns {PIXI.Point} The new point, transformed through this matrix\r\n     */\r\n    apply<P extends IPointData = Point>(pos: IPointData, newPos?: P): P;\r\n    /**\r\n     * Get a new position with the inverse of the current transformation applied.\r\n     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\r\n     * @param pos - The origin\r\n     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\r\n     * @returns {PIXI.Point} The new point, inverse-transformed through this matrix\r\n     */\r\n    applyInverse<P extends IPointData = Point>(pos: IPointData, newPos?: P): P;\r\n    /**\r\n     * Translates the matrix on the x and y.\r\n     * @param x - How much to translate x by\r\n     * @param y - How much to translate y by\r\n     * @returns This matrix. Good for chaining method calls.\r\n     */\r\n    translate(x: number, y: number): this;\r\n    /**\r\n     * Applies a scale transformation to the matrix.\r\n     * @param x - The amount to scale horizontally\r\n     * @param y - The amount to scale vertically\r\n     * @returns This matrix. Good for chaining method calls.\r\n     */\r\n    scale(x: number, y: number): this;\r\n    /**\r\n     * Applies a rotation transformation to the matrix.\r\n     * @param angle - The angle in radians.\r\n     * @returns This matrix. Good for chaining method calls.\r\n     */\r\n    rotate(angle: number): this;\r\n    /**\r\n     * Appends the given Matrix to this Matrix.\r\n     * @param matrix - The matrix to append.\r\n     * @returns This matrix. Good for chaining method calls.\r\n     */\r\n    append(matrix: Matrix): this;\r\n    /**\r\n     * Sets the matrix based on all the available properties\r\n     * @param x - Position on the x axis\r\n     * @param y - Position on the y axis\r\n     * @param pivotX - Pivot on the x axis\r\n     * @param pivotY - Pivot on the y axis\r\n     * @param scaleX - Scale on the x axis\r\n     * @param scaleY - Scale on the y axis\r\n     * @param rotation - Rotation in radians\r\n     * @param skewX - Skew on the x axis\r\n     * @param skewY - Skew on the y axis\r\n     * @returns This matrix. Good for chaining method calls.\r\n     */\r\n    setTransform(x: number, y: number, pivotX: number, pivotY: number, scaleX: number, scaleY: number, rotation: number, skewX: number, skewY: number): this;\r\n    /**\r\n     * Prepends the given Matrix to this Matrix.\r\n     * @param matrix - The matrix to prepend\r\n     * @returns This matrix. Good for chaining method calls.\r\n     */\r\n    prepend(matrix: Matrix): this;\r\n    /**\r\n     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\r\n     * @param transform - The transform to apply the properties to.\r\n     * @returns The transform with the newly applied properties\r\n     */\r\n    decompose(transform: Transform): Transform;\r\n    /**\r\n     * Inverts this matrix\r\n     * @returns This matrix. Good for chaining method calls.\r\n     */\r\n    invert(): this;\r\n    /**\r\n     * Resets this Matrix to an identity (default) matrix.\r\n     * @returns This matrix. Good for chaining method calls.\r\n     */\r\n    identity(): this;\r\n    /**\r\n     * Creates a new Matrix object with the same values as this one.\r\n     * @returns A copy of this matrix. Good for chaining method calls.\r\n     */\r\n    clone(): Matrix;\r\n    /**\r\n     * Changes the values of the given matrix to be the same as the ones in this matrix\r\n     * @param matrix - The matrix to copy to.\r\n     * @returns The matrix given in parameter with its values updated.\r\n     */\r\n    copyTo(matrix: Matrix): Matrix;\r\n    /**\r\n     * Changes the values of the matrix to be the same as the ones in given matrix\r\n     * @param {PIXI.Matrix} matrix - The matrix to copy from.\r\n     * @returns {PIXI.Matrix} this\r\n     */\r\n    copyFrom(matrix: Matrix): this;\r\n    toString(): string;\r\n    /**\r\n     * A default (identity) matrix\r\n     * @readonly\r\n     */\r\n    static get IDENTITY(): Matrix;\r\n    /**\r\n     * A temp matrix\r\n     * @readonly\r\n     */\r\n    static get TEMP_MATRIX(): Matrix;\r\n}\r\n\r\nexport declare interface ObservablePoint extends GlobalMixins.Point, IPoint {\r\n}\r\n\r\n/**\r\n * The ObservablePoint object represents a location in a two-dimensional coordinate system, where `x` represents\r\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\r\n *\r\n * An `ObservablePoint` is a point that triggers a callback when the point's position is changed.\r\n * @memberof PIXI\r\n */\r\nexport declare class ObservablePoint<T = any> implements IPoint {\r\n    /** The callback function triggered when `x` and/or `y` are changed */\r\n    cb: (this: T) => any;\r\n    /** The owner of the callback */\r\n    scope: any;\r\n    _x: number;\r\n    _y: number;\r\n    /**\r\n     * Creates a new `ObservablePoint`\r\n     * @param cb - callback function triggered when `x` and/or `y` are changed\r\n     * @param scope - owner of callback\r\n     * @param {number} [x=0] - position of the point on the x axis\r\n     * @param {number} [y=0] - position of the point on the y axis\r\n     */\r\n    constructor(cb: (this: T) => any, scope: T, x?: number, y?: number);\r\n    /**\r\n     * Creates a clone of this point.\r\n     * The callback and scope params can be overridden otherwise they will default\r\n     * to the clone object's values.\r\n     * @override\r\n     * @param cb - The callback function triggered when `x` and/or `y` are changed\r\n     * @param scope - The owner of the callback\r\n     * @returns a copy of this observable point\r\n     */\r\n    clone(cb?: (this: T) => any, scope?: any): ObservablePoint;\r\n    /**\r\n     * Sets the point to a new `x` and `y` position.\r\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\r\n     * @param {number} [x=0] - position of the point on the x axis\r\n     * @param {number} [y=x] - position of the point on the y axis\r\n     * @returns The observable point instance itself\r\n     */\r\n    set(x?: number, y?: number): this;\r\n    /**\r\n     * Copies x and y from the given point (`p`)\r\n     * @param p - The point to copy from. Can be any of type that is or extends `IPointData`\r\n     * @returns The observable point instance itself\r\n     */\r\n    copyFrom(p: IPointData): this;\r\n    /**\r\n     * Copies this point's x and y into that of the given point (`p`)\r\n     * @param p - The point to copy to. Can be any of type that is or extends `IPointData`\r\n     * @returns The point (`p`) with values updated\r\n     */\r\n    copyTo<T extends IPoint>(p: T): T;\r\n    /**\r\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\r\n     * @param p - The point to check\r\n     * @returns Returns `true` if both `x` and `y` are equal\r\n     */\r\n    equals(p: IPointData): boolean;\r\n    toString(): string;\r\n    /** Position of the observable point on the x axis. */\r\n    get x(): number;\r\n    set x(value: number);\r\n    /** Position of the observable point on the y axis. */\r\n    get y(): number;\r\n    set y(value: number);\r\n}\r\n\r\n/**\r\n * Two Pi.\r\n * @static\r\n * @member {number}\r\n * @memberof PIXI\r\n */\r\nexport declare const PI_2: number;\r\n\r\nexport declare interface Point extends GlobalMixins.Point, IPoint {\r\n}\r\n\r\n/**\r\n * The Point object represents a location in a two-dimensional coordinate system, where `x` represents\r\n * the position on the horizontal axis and `y` represents the position on the vertical axis\r\n * @class\r\n * @memberof PIXI\r\n * @implements {IPoint}\r\n */\r\nexport declare class Point implements IPoint {\r\n    /** Position of the point on the x axis */\r\n    x: number;\r\n    /** Position of the point on the y axis */\r\n    y: number;\r\n    /**\r\n     * Creates a new `Point`\r\n     * @param {number} [x=0] - position of the point on the x axis\r\n     * @param {number} [y=0] - position of the point on the y axis\r\n     */\r\n    constructor(x?: number, y?: number);\r\n    /**\r\n     * Creates a clone of this point\r\n     * @returns A clone of this point\r\n     */\r\n    clone(): Point;\r\n    /**\r\n     * Copies `x` and `y` from the given point into this point\r\n     * @param p - The point to copy from\r\n     * @returns The point instance itself\r\n     */\r\n    copyFrom(p: IPointData): this;\r\n    /**\r\n     * Copies this point's x and y into the given point (`p`).\r\n     * @param p - The point to copy to. Can be any of type that is or extends `IPointData`\r\n     * @returns The point (`p`) with values updated\r\n     */\r\n    copyTo<T extends IPoint>(p: T): T;\r\n    /**\r\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\r\n     * @param p - The point to check\r\n     * @returns Returns `true` if both `x` and `y` are equal\r\n     */\r\n    equals(p: IPointData): boolean;\r\n    /**\r\n     * Sets the point to a new `x` and `y` position.\r\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\r\n     * @param {number} [x=0] - position of the point on the `x` axis\r\n     * @param {number} [y=x] - position of the point on the `y` axis\r\n     * @returns The point instance itself\r\n     */\r\n    set(x?: number, y?: number): this;\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * A class to define a shape via user defined coordinates.\r\n * @memberof PIXI\r\n */\r\nexport declare class Polygon {\r\n    /** An array of the points of this polygon. */\r\n    points: number[];\r\n    /** `false` after moveTo, `true` after `closePath`. In all other cases it is `true`. */\r\n    closeStroke: boolean;\r\n    /**\r\n     * The type of the object, mainly used to avoid `instanceof` checks\r\n     * @default PIXI.SHAPES.POLY\r\n     * @see PIXI.SHAPES\r\n     */\r\n    readonly type: SHAPES.POLY;\r\n    constructor(points: IPointData[] | number[]);\r\n    constructor(...points: IPointData[] | number[]);\r\n    /**\r\n     * Creates a clone of this polygon.\r\n     * @returns - A copy of the polygon.\r\n     */\r\n    clone(): Polygon;\r\n    /**\r\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon.\r\n     * @param x - The X coordinate of the point to test.\r\n     * @param y - The Y coordinate of the point to test.\r\n     * @returns - Whether the x/y coordinates are within this polygon.\r\n     */\r\n    contains(x: number, y: number): boolean;\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * Conversion factor for converting radians to degrees.\r\n * @static\r\n * @member {number} RAD_TO_DEG\r\n * @memberof PIXI\r\n */\r\nexport declare const RAD_TO_DEG: number;\r\n\r\nexport declare interface Rectangle extends GlobalMixins.Rectangle {\r\n}\r\n\r\n/**\r\n * Size object, contains width and height\r\n * @memberof PIXI\r\n * @typedef {object} ISize@typedef {object} ISize\r\n * @property {number} width - Width component\r\n * @property {number} height - Height component\r\n */\r\n/**\r\n * Rectangle object is an area defined by its position, as indicated by its top-left corner\r\n * point (x, y) and by its width and its height.\r\n * @memberof PIXI\r\n */\r\nexport declare class Rectangle {\r\n    /** @default 0 */\r\n    x: number;\r\n    /** @default 0 */\r\n    y: number;\r\n    /** @default 0 */\r\n    width: number;\r\n    /** @default 0 */\r\n    height: number;\r\n    /**\r\n     * The type of the object, mainly used to avoid `instanceof` checks\r\n     * @default PIXI.SHAPES.RECT\r\n     * @see PIXI.SHAPES\r\n     */\r\n    readonly type: SHAPES.RECT;\r\n    /**\r\n     * @param x - The X coordinate of the upper-left corner of the rectangle\r\n     * @param y - The Y coordinate of the upper-left corner of the rectangle\r\n     * @param width - The overall width of the rectangle\r\n     * @param height - The overall height of the rectangle\r\n     */\r\n    constructor(x?: string | number, y?: string | number, width?: string | number, height?: string | number);\r\n    /** Returns the left edge of the rectangle. */\r\n    get left(): number;\r\n    /** Returns the right edge of the rectangle. */\r\n    get right(): number;\r\n    /** Returns the top edge of the rectangle. */\r\n    get top(): number;\r\n    /** Returns the bottom edge of the rectangle. */\r\n    get bottom(): number;\r\n    /** A constant empty rectangle. */\r\n    static get EMPTY(): Rectangle;\r\n    /**\r\n     * Creates a clone of this Rectangle\r\n     * @returns a copy of the rectangle\r\n     */\r\n    clone(): Rectangle;\r\n    /**\r\n     * Copies another rectangle to this one.\r\n     * @param rectangle - The rectangle to copy from.\r\n     * @returns Returns itself.\r\n     */\r\n    copyFrom(rectangle: Rectangle): Rectangle;\r\n    /**\r\n     * Copies this rectangle to another one.\r\n     * @param rectangle - The rectangle to copy to.\r\n     * @returns Returns given parameter.\r\n     */\r\n    copyTo(rectangle: Rectangle): Rectangle;\r\n    /**\r\n     * Checks whether the x and y coordinates given are contained within this Rectangle\r\n     * @param x - The X coordinate of the point to test\r\n     * @param y - The Y coordinate of the point to test\r\n     * @returns Whether the x/y coordinates are within this Rectangle\r\n     */\r\n    contains(x: number, y: number): boolean;\r\n    /**\r\n     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\r\n     * Returns true only if the area of the intersection is >0, this means that Rectangles\r\n     * sharing a side are not overlapping. Another side effect is that an arealess rectangle\r\n     * (width or height equal to zero) can't intersect any other rectangle.\r\n     * @param {Rectangle} other - The Rectangle to intersect with `this`.\r\n     * @param {Matrix} transform - The transformation matrix of `other`.\r\n     * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\r\n     */\r\n    intersects(other: Rectangle, transform?: Matrix): boolean;\r\n    /**\r\n     * Pads the rectangle making it grow in all directions.\r\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\r\n     * @param paddingX - The horizontal padding amount.\r\n     * @param paddingY - The vertical padding amount.\r\n     * @returns Returns itself.\r\n     */\r\n    pad(paddingX?: number, paddingY?: number): this;\r\n    /**\r\n     * Fits this rectangle around the passed one.\r\n     * @param rectangle - The rectangle to fit.\r\n     * @returns Returns itself.\r\n     */\r\n    fit(rectangle: Rectangle): this;\r\n    /**\r\n     * Enlarges rectangle that way its corners lie on grid\r\n     * @param resolution - resolution\r\n     * @param eps - precision\r\n     * @returns Returns itself.\r\n     */\r\n    ceil(resolution?: number, eps?: number): this;\r\n    /**\r\n     * Enlarges this rectangle to include the passed rectangle.\r\n     * @param rectangle - The rectangle to include.\r\n     * @returns Returns itself.\r\n     */\r\n    enlarge(rectangle: Rectangle): this;\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its\r\n * top-left corner point (x, y) and by its width and its height and its radius.\r\n * @memberof PIXI\r\n */\r\nexport declare class RoundedRectangle {\r\n    /** @default 0 */\r\n    x: number;\r\n    /** @default 0 */\r\n    y: number;\r\n    /** @default 0 */\r\n    width: number;\r\n    /** @default 0 */\r\n    height: number;\r\n    /** @default 20 */\r\n    radius: number;\r\n    /**\r\n     * The type of the object, mainly used to avoid `instanceof` checks\r\n     * @default PIXI.SHAPES.RREC\r\n     * @see PIXI.SHAPES\r\n     */\r\n    readonly type: SHAPES.RREC;\r\n    /**\r\n     * @param x - The X coordinate of the upper-left corner of the rounded rectangle\r\n     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\r\n     * @param width - The overall width of this rounded rectangle\r\n     * @param height - The overall height of this rounded rectangle\r\n     * @param radius - Controls the radius of the rounded corners\r\n     */\r\n    constructor(x?: number, y?: number, width?: number, height?: number, radius?: number);\r\n    /**\r\n     * Creates a clone of this Rounded Rectangle.\r\n     * @returns - A copy of the rounded rectangle.\r\n     */\r\n    clone(): RoundedRectangle;\r\n    /**\r\n     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\r\n     * @param x - The X coordinate of the point to test.\r\n     * @param y - The Y coordinate of the point to test.\r\n     * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\r\n     */\r\n    contains(x: number, y: number): boolean;\r\n    toString(): string;\r\n}\r\n\r\n/**\r\n * Constants that identify shapes, mainly to prevent `instanceof` calls.\r\n * @static\r\n * @memberof PIXI\r\n * @enum {number}\r\n * @property {number} POLY Polygon\r\n * @property {number} RECT Rectangle\r\n * @property {number} CIRC Circle\r\n * @property {number} ELIP Ellipse\r\n * @property {number} RREC Rounded Rectangle\r\n */\r\nexport declare enum SHAPES {\r\n    POLY = 0,\r\n    RECT = 1,\r\n    CIRC = 2,\r\n    ELIP = 3,\r\n    RREC = 4\r\n}\r\n\r\nexport declare interface Transform extends GlobalMixins.Transform {\r\n}\r\n\r\n/**\r\n * Transform that takes care about its versions.\r\n * @memberof PIXI\r\n */\r\nexport declare class Transform {\r\n    /** A default (identity) transform. */\r\n    static readonly IDENTITY: Transform;\r\n    /** The world transformation matrix. */\r\n    worldTransform: Matrix;\r\n    /** The local transformation matrix. */\r\n    localTransform: Matrix;\r\n    /** The coordinate of the object relative to the local coordinates of the parent. */\r\n    position: ObservablePoint;\r\n    /** The scale factor of the object. */\r\n    scale: ObservablePoint;\r\n    /** The pivot point of the displayObject that it rotates around. */\r\n    pivot: ObservablePoint;\r\n    /** The skew amount, on the x and y axis. */\r\n    skew: ObservablePoint;\r\n    /** The locally unique ID of the parent's world transform used to calculate the current world transformation matrix. */\r\n    _parentID: number;\r\n    /** The locally unique ID of the world transform. */\r\n    _worldID: number;\r\n    /** The rotation amount. */\r\n    protected _rotation: number;\r\n    /**\r\n     * The X-coordinate value of the normalized local X axis,\r\n     * the first column of the local transformation matrix without a scale.\r\n     */\r\n    protected _cx: number;\r\n    /**\r\n     * The Y-coordinate value of the normalized local X axis,\r\n     * the first column of the local transformation matrix without a scale.\r\n     */\r\n    protected _sx: number;\r\n    /**\r\n     * The X-coordinate value of the normalized local Y axis,\r\n     * the second column of the local transformation matrix without a scale.\r\n     */\r\n    protected _cy: number;\r\n    /**\r\n     * The Y-coordinate value of the normalized local Y axis,\r\n     * the second column of the local transformation matrix without a scale.\r\n     */\r\n    protected _sy: number;\r\n    /** The locally unique ID of the local transform. */\r\n    protected _localID: number;\r\n    /** The locally unique ID of the local transform used to calculate the current local transformation matrix. */\r\n    protected _currentLocalID: number;\r\n    constructor();\r\n    /** Called when a value changes. */\r\n    protected onChange(): void;\r\n    /** Called when the skew or the rotation changes. */\r\n    protected updateSkew(): void;\r\n    toString(): string;\r\n    /** Updates the local transformation matrix. */\r\n    updateLocalTransform(): void;\r\n    /**\r\n     * Updates the local and the world transformation matrices.\r\n     * @param parentTransform - The parent transform\r\n     */\r\n    updateTransform(parentTransform: Transform): void;\r\n    /**\r\n     * Decomposes a matrix and sets the transforms properties based on it.\r\n     * @param matrix - The matrix to decompose\r\n     */\r\n    setFromMatrix(matrix: Matrix): void;\r\n    /** The rotation of the object in radians. */\r\n    get rotation(): number;\r\n    set rotation(value: number);\r\n}\r\n\r\nexport { }\r\n"
    ]
  