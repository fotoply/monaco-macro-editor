
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\client\\pixi\\board.d.ts",
      "import { ConfiguredDocumentClass } from '../../../types/helperTypes';\nimport { BaseScene } from '../../common/documents.mjs';\n\ndeclare global {\n  /**\n   * The virtual tabletop environment is implemented using a WebGL powered HTML 5 canvas using the powerful PIXI.js\n   * library. The canvas is comprised of an ordered sequence of layers which define rendering groups and collections of\n   * objects that are drawn on the canvas itself.\n   *\n   * @see {@link CanvasLayer} An abstract class for all Canvas layers.\n   * @see {@link PlaceablesLayer} An abstract class for Canvas Layers which contain Placeable Objects.\n   * @see {@link PlaceableObject} An abstract class for objects which are placed into the Scene and drawn on the canvas.\n   *\n   * @example <caption>Example Canvas commands</caption>\n   * ```typescript\n   * canvas.ready; // Is the canvas ready for use?\n   * canvas.scene; // The currently viewed Scene document.\n   * canvas.dimensions; // The dimensions of the current Scene.\n   * canvas.draw(); // Completely re-draw the game canvas (this is usually unnecessary).\n   * canvas.pan(x, y, zoom); // Pan the canvas to new coordinates and scale.\n   * canvas.recenter(); // Re-center the canvas on the currently controlled Token.\n   * ```\n   */\n  class Canvas {\n    constructor();\n\n    /**\n     * A reference to the currently displayed Scene document, or null if the Canvas is currently blank.\n     * @defaultValue `null`\n     */\n    scene: StoredDocument<InstanceType<ConfiguredDocumentClass<typeof Scene>>> | null;\n\n    /**\n     * The current pixel dimensions of the displayed Scene, or null if the Canvas is blank.\n     * @defaultValue `null`\n     */\n    dimensions: Canvas.Dimensions | null;\n\n    /**\n     * A reference to the HeadsUpDisplay container which overlays HTML rendering on top of this Canvas.\n     * @defaultValue `null`\n     */\n    hud: HeadsUpDisplay | null;\n\n    /**\n     * An Array of pending canvas operations which should trigger on the next re-paint\n     * @defaultValue `[]`\n     */\n    pendingOperations: Array<[fn: (args: any[]) => void, scope: any, args: any[]]>;\n\n    /**\n     * A perception manager interface for batching lighting, sight, and sound updates\n     */\n    perception: PerceptionManager;\n\n    /**\n     * A flag for whether the game Canvas is ready to be used. False if the canvas is not yet drawn, true otherwise.\n     * @defaultValue `false`\n     */\n    ready: boolean;\n\n    /**\n     * A flag to indicate whether a new Scene is currently being drawn.\n     * @defaultValue `false`\n     */\n    loading: boolean;\n\n    /**\n     * A flag for whether the game Canvas is initialized and ready for drawing.\n     * @defaultValue `false`\n     */\n    initialized: boolean;\n\n    /**\n     * A promise that resolves when the canvas is first initialized and ready.\n     */\n    initializing: Promise<void> | null;\n\n    /**\n     * Track the timestamp of the last stage zoom operation\n     * @defaultValue `0`\n     */\n    protected _zoomTime: number;\n\n    /**\n     * Track the last automatic pan time to throttle\n     * @defaultValue `0`\n     */\n    protected _panTime: number;\n\n    /**\n     * An object of data which is temporarily cached to be reloaded after the canvas is drawn\n     * @defaultValue `{}`\n     */\n    protected _reload: Partial<{ scene: string; layer: string; controlledTokens: string[]; targetedTokens: string[] }>;\n\n    /**\n     * A Set of unique pending operation names to ensure operations are only performed once\n     */\n    protected _pendingOperationNames: Set<string>;\n\n    /**\n     * The pixel radius of blur distance that should be applied for the current zoom level\n     * @defaultValue `0`\n     */\n    blurDistance: number;\n\n    /**\n     * An array of blur filter instances which are modified by the zoom level and the \"soft shadows\" setting\n     * @defaultValue `[]`\n     */\n    blurFilters: PIXI.filters.BlurFilter[];\n\n    /**\n     * A reference to the MouseInteractionManager that is currently controlling pointer-based interaction, or null.\n     */\n    currentMouseManager: MouseInteractionManager<PIXI.Container> | null;\n\n    /**\n     * Record framerate performance data\n     */\n    fps: {\n      /** @defaultValue `[]` */\n      values: number[];\n\n      /** @defaultValue `0` */\n      average: number;\n\n      /** @defaultValue `0` */\n      render: number;\n\n      /** @defaultValue `document.getElementById(\"fps\")` */\n      element: HTMLElement;\n    };\n\n    /**\n     * The singleton interaction manager instance which handles mouse interaction on the Canvas.\n     */\n    mouseInteractionManager: MouseInteractionManager<PIXI.Container> | undefined;\n\n    /**\n     * The renderer screen dimensions.\n     * @defaultValue `[0, 0]`\n     */\n    screenDimensions: [x: number, y: number];\n\n    /**\n     * Initialize the Canvas by creating the HTML element and PIXI application.\n     * This step should only ever be performed once per client session.\n     * Subsequent requests to reset the canvas should go through Canvas#draw\n     */\n    initialize(): void;\n\n    app?: PIXI.Application;\n\n    stage?: PIXI.Container;\n\n    protected _dragDrop?: DragDrop;\n\n    outline?: PIXI.Graphics;\n\n    msk?: PIXI.Graphics;\n\n    readonly primary?: PrimaryCanvasGroup;\n\n    readonly effects?: EffectsCanvasGroup;\n\n    readonly interface?: InterfaceCanvasGroup;\n\n    readonly background?: BackgroundLayer;\n\n    readonly drawings?: DrawingsLayer;\n\n    readonly grid?: GridLayer;\n\n    readonly walls?: WallsLayer;\n\n    readonly templates?: TemplateLayer;\n\n    readonly notes?: NotesLayer;\n\n    readonly tokens?: TokenLayer;\n\n    readonly foreground?: ForegroundLayer;\n\n    readonly sounds?: SoundsLayer;\n\n    readonly lighting?: LightingLayer;\n\n    readonly sight?: SightLayer;\n\n    readonly weather?: WeatherLayer;\n\n    readonly controls?: ControlsLayer;\n\n    /**\n     * Display warnings for known performance issues which may occur due to the user's hardware or browser configuration\n     * @internal\n     */\n    protected _displayPerformanceWarnings(): void;\n\n    /**\n     * The id of the currently displayed Scene.\n     */\n    get id(): string | null;\n\n    /**\n     * A mapping of named CanvasLayer classes which defines the layers which comprise the Scene.\n     */\n    static get layers(): typeof CONFIG.Canvas.layers;\n\n    /**\n     * An Array of all CanvasLayer instances which are active on the Canvas board\n     */\n    get layers(): CanvasLayer[];\n\n    /**\n     * Return a reference to the active Canvas Layer\n     */\n    get activeLayer(): CanvasLayer | null;\n\n    /**\n     * Initialize the group containers of the game Canvas.\n     * @internal\n     */\n    protected _createGroups(): void;\n\n    /**\n     * When re-drawing the canvas, first tear down or discontinue some existing processes\n     */\n    tearDown(): Promise<void>;\n\n    /**\n     * Draw the game canvas.\n     * @param scene - A specific Scene document to render on the Canvas\n     * @returns A Promise which resolves once the Canvas is fully drawn\n     */\n    draw(scene?: InstanceType<ConfiguredDocumentClass<typeof Scene>>): Promise<this>;\n\n    performance?: PerformanceSettings;\n\n    /**\n     * Get the value of a GL parameter\n     * @param parameter - The GL parameter to retrieve\n     * @returns The returned value type depends of the parameter to retrieve\n     */\n    getGLParameter(parameter: string): unknown;\n\n    /**\n     * Get the canvas active dimensions based on the size of the scene's map.\n     * We expand the image size by a factor of 1.5 and round to the nearest 2x grid size.\n     * The rounding accomplishes that the padding buffer around the map always contains whole grid spaces.\n     * @see {@link documents.BaseScene.getDimensions}\n     * @param data - The scene dimensions data being established\n     */\n    static getDimensions(data: Canvas.DimensionsData): Canvas.Dimensions;\n\n    /**\n     * Configure performance settings for hte canvas application based on the selected performance mode\n     * @internal\n     */\n    protected _configurePerformanceMode(): PerformanceSettings;\n\n    /**\n     * Once the canvas is drawn, initialize control, visibility, and audio states\n     */\n    protected _initialize(): Promise<void>;\n\n    /**\n     * Initialize the starting view of the canvas stage\n     * If we are re-drawing a scene which was previously rendered, restore the prior view position\n     * Otherwise set the view to the top-left corner of the scene at standard scale\n     */\n    protected _initializeCanvasPosition(): void;\n\n    /**\n     * Initialize a CanvasLayer in the activation state\n     */\n    protected _initializeCanvasLayer(): void;\n\n    /**\n     * Initialize a token or set of tokens which should be controlled.\n     * Restore controlled and targeted tokens from before the re-draw.\n     */\n    protected _initializeTokenControl(): void;\n\n    /**\n     * Given an embedded object name, get the canvas layer for that object\n     */\n    getLayerByEmbeddedName<T extends string>(\n      embeddedName: T\n    ): T extends keyof EmbeddedEntityNameToLayerMap ? Exclude<EmbeddedEntityNameToLayerMap[T], undefined> | null : null;\n\n    /**\n     * Activate a specific CanvasLayer by its canonical name\n     * @param layerName - The named layer to activate\n     */\n    activateLayer(layerName: LayerName): void;\n\n    /**\n     * Activate framerate tracking by adding an HTML element to the display and refreshing it every frame.\n     */\n    activateFPSMeter(): void;\n\n    /**\n     * Deactivate framerate tracking by canceling ticker updates and removing the HTML element.\n     */\n    deactivateFPSMeter(): void;\n\n    /**\n     * Measure average framerate per second over the past 30 frames\n     * @internal\n     */\n    protected _measureFPS(): void;\n\n    /**\n     * Pan the canvas to a certain \\{x,y\\} coordinate and a certain zoom level\n     * @param options - (default: `{}`)\n     */\n    pan(options?: PanView): void;\n\n    /**\n     * Animate panning the canvas to a certain destination coordinate and zoom scale\n     * Customize the animation speed with additional options\n     * Returns a Promise which is resolved once the animation has completed\n     *\n     * @param view - The desired view parameters\n     *               (default: `{}`)\n     * @returns A Promise which resolves once the animation has been completed\n     */\n    animatePan(view?: Partial<AnimatedPanView>): ReturnType<typeof CanvasAnimation.animateLinear>;\n\n    /**\n     * Recenter the canvas\n     * Otherwise, pan the stage to put the top-left corner of the map in the top-left corner of the window\n     * @returns A Promise which resolves once the animation has been completed\n     */\n    recenter(coordinates?: PanView): ReturnType<this['animatePan']>;\n\n    /**\n     * Highlight objects on any layers which are visible\n     */\n    highlightObjects(active: boolean): void;\n\n    /**\n     * Get the constrained zoom scale parameter which is allowed by the maxZoom parameter\n     * @param x     - The requested x-coordinate\n     * @param y     - The requested y-coordinate\n     * @param scale - The requested scale\n     * @returns The allowed scale\n     */\n    protected _constrainView({ x, y, scale }: Canvas.View): Canvas.View;\n\n    /**\n     * Create a BlurFilter instance and register it to the array for updates when the zoom level changes.\n     */\n    createBlurFilter(): PIXI.filters.BlurFilter;\n\n    /**\n     * Update the blur strength depending on the scale of the canvas stage\n     * @param scale - (default: `this.stage.scale.x`)\n     */\n    protected updateBlur(scale?: number): void;\n\n    /**\n     * Sets the background color.\n     * @param color - The color to set the canvas background to.\n     */\n    setBackgroundColor(color: string): void;\n\n    /**\n     * Attach event listeners to the game canvas to handle click and interaction events\n     */\n    protected _addListeners(): void;\n\n    /**\n     * Handle normal mouse movement.\n     * Throttle cursor position updates to 100ms intervals\n     */\n    protected _onMouseMove(event: PIXI.InteractionEvent): void;\n\n    /**\n     * Handle left mouse-click events occurring on the Canvas stage or its active Layer.\n     * @see {@link MouseInteractionManager#_handleClickLeft}\n     */\n    protected _onClickLeft(event: PIXI.InteractionEvent): void;\n\n    /**\n     * Handle double left-click events occurring on the Canvas stage.\n     * @see {@link MouseInteractionManager#_handleClickLeft2}\n     */\n    protected _onClickLeft2(event: PIXI.InteractionEvent): void;\n\n    /**\n     * Handle the beginning of a left-mouse drag workflow on the Canvas stage or its active Layer.\n     * @see {@link MouseInteractionManager#_handleDragStart}\n     */\n    protected _onDragLeftStart(event: PIXI.InteractionEvent): void;\n\n    /**\n     * Handle mouse movement events occurring on the Canvas stage or it's active layer\n     * @see {@link MouseInteractionManager#_handleDragMove}\n     */\n    protected _onDragLeftMove(event: PIXI.InteractionEvent): void;\n\n    /**\n     * Handle the conclusion of a left-mouse drag workflow when the mouse button is released.\n     * @see {@link MouseInteractionManager#_handleDragDrop}\n     */\n    protected _onDragLeftDrop(\n      event: PIXI.InteractionEvent\n    ): ReturnType<PlaceablesLayer<any>['selectObjects']> | ReturnType<TokenLayer['targetObjects']> | void;\n\n    /**\n     * Handle the cancellation of a left-mouse drag workflow\n     * @see {@link MouseInteractionManager#_handleDragCancel}\n     */\n    protected _onDragLeftCancel(event: PointerEvent): PIXI.Graphics | void;\n\n    /**\n     * Handle right mouse-click events occurring on the Canvas stage or it's active layer\n     * @see {@link MouseInteractionManager#_handleClickRight}\n     */\n    protected _onClickRight(event: PIXI.InteractionEvent): void;\n\n    /**\n     * Handle right-mouse drag events occuring on the Canvas stage or an active Layer\n     * @see {@link MouseInteractionManager#_handleDragMove}\n     */\n    protected _onDragRightMove(event: PIXI.InteractionEvent): void;\n\n    /**\n     * Handle the conclusion of a right-mouse drag workflow the Canvas stage.\n     * @see {@link MouseInteractionManager#_handleDragDrop}\n     */\n    protected _onDragRightDrop(event: PIXI.InteractionEvent): void;\n\n    /**\n     * Determine selection coordinate rectangle during a mouse-drag workflow\n     */\n    protected _onDragSelect(event: PIXI.InteractionEvent): void;\n\n    /**\n     * Pan the canvas view when the cursor position gets close to the edge of the frame\n     * @param event - The originating mouse movement event\n     */\n    protected _onDragCanvasPan(event: MouseEvent): ReturnType<this['animatePan']> | void;\n\n    /**\n     * Handle window resizing with the dimensions of the window viewport change\n     * @param event - The Window resize event\n     *                (default: `null`)\n     */\n    protected _onResize(event?: UIEvent | null): false | void;\n\n    /**\n     * Handle mousewheel events which adjust the scale of the canvas\n     * @param event - The mousewheel event that zooms the canvas\n     */\n    protected _onMouseWheel(event: WheelEvent): void;\n\n    /**\n     * Event handler for the drop portion of a drag-and-drop event.\n     * @internal\n     */\n    protected _onDrop(event: DragEvent): void;\n\n    /**\n     * Add a pending canvas operation that should fire once the socket handling workflow concludes.\n     * This registers operations by a unique string name into a queue - avoiding repeating the same work multiple times.\n     * This is especially helpful for multi-object updates to avoid costly and redundant refresh operations.\n     * @param name  - A unique name for the pending operation, conventionally Class.method\n     * @param fn    - The unbound function to execute later\n     * @param scope - The scope to which the method should be bound when called\n     * @param args  - Arbitrary arguments to pass to the method when called\n     */\n    addPendingOperation<S, A>(name: string, fn: (this: S, args: A) => void, scope: S, args: A): void;\n\n    /**\n     * Fire all pending functions that are registered in the pending operations queue and empty it.\n     */\n    triggerPendingOperations(): void;\n\n    /**\n     * Get a reference to the a specific CanvasLayer by it's name\n     * @param layerName - The name of the canvas layer to get\n     * @deprecated since v9, will be deleted in v10\n     */\n    getLayer(layerName: any): {\n      BackgroundLayer: Canvas['background'];\n      DrawingsLayer: Canvas['drawings'];\n      GridLayer: Canvas['grid'];\n      TemplateLayer: Canvas['templates'];\n      TokenLayer: Canvas['tokens'];\n      WallsLayer: Canvas['walls'];\n      LightingLayer: Canvas['lighting'];\n      WeatherLayer: Canvas['weather'];\n      SightLayer: Canvas['sight'];\n      SoundsLayer: Canvas['sounds'];\n      NotesLayer: Canvas['notes'];\n      ControlsLayer: Canvas['controls'];\n    };\n  }\n\n  namespace Canvas {\n    interface Dimensions extends ReturnType<typeof BaseScene['getDimensions']> {\n      rect: PIXI.Rectangle;\n      sceneRect: PIXI.Rectangle;\n      maxR: number;\n    }\n\n    interface DimensionsData {\n      width?: number;\n      height?: number;\n      grid: number;\n      gridDistance: number;\n      padding: number;\n      shiftX: number;\n      shiftY: number;\n    }\n\n    interface DropPosition {\n      x: number;\n      y: number;\n    }\n\n    interface View {\n      x: number;\n      y: number;\n      scale: number;\n    }\n  }\n}\n\ninterface PerformanceSettings {\n  mode: foundry.CONST.CANVAS_PERFORMANCE_MODES;\n  blur: {\n    enabled: boolean;\n    illumination: boolean;\n  };\n  mipmap: 'ON' | 'OFF';\n  msaa: boolean;\n  fps: number;\n  tokenAnimation: boolean;\n  lightAnimation: boolean;\n  textures: {\n    enabled: boolean;\n    maxSize: number;\n    p2Steps: number;\n    p2StepsMax: number;\n  };\n}\n\ninterface PanView {\n  /**\n   * The x-coordinate of the pan destination\n   * @defaultValue `null`\n   */\n  x?: number | null;\n\n  /**\n   * The y-coordinate of the pan destination\n   * @defaultValue `null`\n   */\n  y?: number | null;\n\n  /**\n   * The zoom level (max of CONFIG.Canvas.maxZoom) of the action\n   * @defaultValue `null`\n   */\n  scale?: number | null;\n}\n\ninterface AnimatedPanView {\n  /**\n   * The destination x-coordinate\n   */\n  x?: number;\n\n  /**\n   * The destination y-coordinate\n   */\n  y?: number;\n\n  /**\n   * The destination zoom scale\n   */\n  scale?: number;\n\n  /**\n   * The total duration of the animation in milliseconds; used if speed is not set\n   * @defaultValue 250\n   */\n  duration: number;\n\n  /**\n   * The speed of animation in pixels per second; overrides duration if set\n   */\n  speed?: number;\n}\n\ninterface EmbeddedEntityNameToLayerMap {\n  AmbientLight: Canvas['lighting'];\n  AmbientSound: Canvas['sounds'];\n  Drawing: Canvas['drawings'];\n  Note: Canvas['notes'];\n  MeasuredTemplate: Canvas['templates'];\n  Tile: Canvas['background'];\n  Token: Canvas['tokens'];\n  Wall: Canvas['walls'];\n}\n\ntype LayerName =\n  | 'grid'\n  | 'sight'\n  | 'effects'\n  | 'controls'\n  | 'lighting'\n  | 'sounds'\n  | 'drawings'\n  | 'notes'\n  | 'templates'\n  | 'background'\n  | 'foreground'\n  | 'tokens'\n  | 'walls';\n"
    ]
  