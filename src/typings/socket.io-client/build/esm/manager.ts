
    export default [
      "socket.io-client\\build\\esm\\manager.d.ts",
      "import { Socket as Engine, SocketOptions as EngineOptions } from \"engine.io-client\";\nimport { Socket, SocketOptions } from \"./socket.js\";\nimport { Packet } from \"socket.io-parser\";\nimport { DefaultEventsMap, EventsMap, Emitter } from \"@socket.io/component-emitter\";\nexport interface ManagerOptions extends EngineOptions {\n    /**\n     * Should we force a new Manager for this connection?\n     * @default false\n     */\n    forceNew: boolean;\n    /**\n     * Should we multiplex our connection (reuse existing Manager) ?\n     * @default true\n     */\n    multiplex: boolean;\n    /**\n     * The path to get our client file from, in the case of the server\n     * serving it\n     * @default '/socket.io'\n     */\n    path: string;\n    /**\n     * Should we allow reconnections?\n     * @default true\n     */\n    reconnection: boolean;\n    /**\n     * How many reconnection attempts should we try?\n     * @default Infinity\n     */\n    reconnectionAttempts: number;\n    /**\n     * The time delay in milliseconds between reconnection attempts\n     * @default 1000\n     */\n    reconnectionDelay: number;\n    /**\n     * The max time delay in milliseconds between reconnection attempts\n     * @default 5000\n     */\n    reconnectionDelayMax: number;\n    /**\n     * Used in the exponential backoff jitter when reconnecting\n     * @default 0.5\n     */\n    randomizationFactor: number;\n    /**\n     * The timeout in milliseconds for our connection attempt\n     * @default 20000\n     */\n    timeout: number;\n    /**\n     * Should we automatically connect?\n     * @default true\n     */\n    autoConnect: boolean;\n    /**\n     * the parser to use. Defaults to an instance of the Parser that ships with socket.io.\n     */\n    parser: any;\n}\ninterface ManagerReservedEvents {\n    open: () => void;\n    error: (err: Error) => void;\n    ping: () => void;\n    packet: (packet: Packet) => void;\n    close: (reason: string) => void;\n    reconnect_failed: () => void;\n    reconnect_attempt: (attempt: number) => void;\n    reconnect_error: (err: Error) => void;\n    reconnect: (attempt: number) => void;\n}\nexport declare class Manager<ListenEvents extends EventsMap = DefaultEventsMap, EmitEvents extends EventsMap = ListenEvents> extends Emitter<{}, {}, ManagerReservedEvents> {\n    /**\n     * The Engine.IO client instance\n     *\n     * @public\n     */\n    engine: Engine;\n    /**\n     * @private\n     */\n    _autoConnect: boolean;\n    /**\n     * @private\n     */\n    _readyState: \"opening\" | \"open\" | \"closed\";\n    /**\n     * @private\n     */\n    _reconnecting: boolean;\n    private readonly uri;\n    opts: Partial<ManagerOptions>;\n    private nsps;\n    private subs;\n    private backoff;\n    private setTimeoutFn;\n    private _reconnection;\n    private _reconnectionAttempts;\n    private _reconnectionDelay;\n    private _randomizationFactor;\n    private _reconnectionDelayMax;\n    private _timeout;\n    private encoder;\n    private decoder;\n    private skipReconnect;\n    /**\n     * `Manager` constructor.\n     *\n     * @param uri - engine instance or engine uri/opts\n     * @param opts - options\n     * @public\n     */\n    constructor(opts: Partial<ManagerOptions>);\n    constructor(uri?: string, opts?: Partial<ManagerOptions>);\n    constructor(uri?: string | Partial<ManagerOptions>, opts?: Partial<ManagerOptions>);\n    /**\n     * Sets the `reconnection` config.\n     *\n     * @param {Boolean} v - true/false if it should automatically reconnect\n     * @return {Manager} self or value\n     * @public\n     */\n    reconnection(v: boolean): this;\n    reconnection(): boolean;\n    reconnection(v?: boolean): this | boolean;\n    /**\n     * Sets the reconnection attempts config.\n     *\n     * @param {Number} v - max reconnection attempts before giving up\n     * @return {Manager} self or value\n     * @public\n     */\n    reconnectionAttempts(v: number): this;\n    reconnectionAttempts(): number;\n    reconnectionAttempts(v?: number): this | number;\n    /**\n     * Sets the delay between reconnections.\n     *\n     * @param {Number} v - delay\n     * @return {Manager} self or value\n     * @public\n     */\n    reconnectionDelay(v: number): this;\n    reconnectionDelay(): number;\n    reconnectionDelay(v?: number): this | number;\n    /**\n     * Sets the randomization factor\n     *\n     * @param v - the randomization factor\n     * @return self or value\n     * @public\n     */\n    randomizationFactor(v: number): this;\n    randomizationFactor(): number;\n    randomizationFactor(v?: number): this | number;\n    /**\n     * Sets the maximum delay between reconnections.\n     *\n     * @param v - delay\n     * @return self or value\n     * @public\n     */\n    reconnectionDelayMax(v: number): this;\n    reconnectionDelayMax(): number;\n    reconnectionDelayMax(v?: number): this | number;\n    /**\n     * Sets the connection timeout. `false` to disable\n     *\n     * @param v - connection timeout\n     * @return self or value\n     * @public\n     */\n    timeout(v: number | boolean): this;\n    timeout(): number | boolean;\n    timeout(v?: number | boolean): this | number | boolean;\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    private maybeReconnectOnOpen;\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn?: (err?: Error) => void): this;\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn?: (err?: Error) => void): this;\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    private onopen;\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    private onping;\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    private ondata;\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    private ondecoded;\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    private onerror;\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp: string, opts?: Partial<SocketOptions>): Socket;\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket: Socket): void;\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet: Partial<Packet & {\n        query: string;\n        options: any;\n    }>): void;\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    private cleanup;\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close(): void;\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    private disconnect;\n    /**\n     * Called upon engine close.\n     *\n     * @private\n     */\n    private onclose;\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    private reconnect;\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    private onreconnect;\n}\nexport {};\n"
    ]
  